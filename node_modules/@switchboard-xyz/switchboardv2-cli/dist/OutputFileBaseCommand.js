"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const core_1 = require("@oclif/core");
const anchor = tslib_1.__importStar(require("@project-serum/anchor"));
const switchboard_v2_1 = require("@switchboard-xyz/switchboard-v2");
const big_js_1 = tslib_1.__importDefault(require("big.js"));
const fs_1 = tslib_1.__importDefault(require("fs"));
const path_1 = tslib_1.__importDefault(require("path"));
const BaseCommand_1 = tslib_1.__importDefault(require("./BaseCommand"));
class OutputFileBaseCommand extends BaseCommand_1.default {
    async init() {
        await super.init();
        const { flags } = await this.parse(this.constructor);
        BaseCommand_1.default.flags = flags;
        const parsedPath = path_1.default.parse(flags.outputFile.startsWith("/") || flags.outputFile.startsWith("C:")
            ? flags.outputFile
            : path_1.default.join(process.cwd(), flags.outputFile));
        this.outputBasePath = path_1.default.join(parsedPath.dir, parsedPath.name);
        if (parsedPath.ext === ".json" || flags.json) {
            this.outputJsonFile = `${this.outputBasePath}.json`;
            if (fs_1.default.existsSync(this.outputJsonFile) && !flags.force) {
                throw new Error(`output json file already exists: ${this.outputJsonFile}`);
            }
        }
        if (parsedPath.ext === ".csv" || flags.csv) {
            this.outputCsvFile = `${this.outputBasePath}.csv`;
            if (fs_1.default.existsSync(this.outputCsvFile) && !flags.force) {
                throw new Error(`output csv file already exists: ${this.outputCsvFile}`);
            }
        }
        if (!(this.outputJsonFile || this.outputCsvFile)) {
            throw new Error(`no output format specified, try --json, or --csv`);
        }
    }
    jsonReplacers(key, value) {
        if (typeof value === "string") {
            return value;
        }
        else if (typeof value === "number") {
            return value;
        }
        else if (typeof value === "boolean") {
            return value.toString();
        }
        else {
            if (value instanceof big_js_1.default) {
                return value.toString();
            }
            else if (anchor.BN.isBN(value)) {
                return value.toString(10);
            }
            else if (("scale" in value && "mantissa" in value) ||
                value instanceof switchboard_v2_1.SwitchboardDecimal) {
                return new switchboard_v2_1.SwitchboardDecimal(value.mantissa, value.scale)
                    .toBig()
                    .toString();
            }
        }
        return value;
    }
    save(rows, headers) {
        if (rows) {
            this.saveJson(rows);
        }
        if (rows !== undefined && headers !== undefined) {
            this.saveCsv(rows, headers);
        }
    }
    saveJson(rows) {
        if (this.outputJsonFile) {
            fs_1.default.writeFileSync(this.outputJsonFile, JSON.stringify(rows, this.jsonReplacers, 2));
        }
    }
    saveCsv(rows, headers) {
        if (this.outputCsvFile) {
            const grid = [];
            grid.push(headers);
            if (Array.isArray(rows)) {
                rows.forEach((row) => {
                    const cols = [];
                    headers.forEach((col) => {
                        const val = row[col];
                        cols.push(typeof val === "string" ? val : this.jsonReplacers(undefined, val));
                    });
                    grid.push(cols);
                });
            }
            else {
                const cols = [];
                headers.forEach((col) => {
                    const val = rows[col];
                    cols.push(typeof val === "string" ? val : this.jsonReplacers(undefined, val));
                });
                grid.push(cols);
            }
            const lines = grid.map((col) => col.join(","));
            fs_1.default.writeFileSync(this.outputCsvFile, lines.join("\n"));
        }
    }
}
OutputFileBaseCommand.flags = {
    ...BaseCommand_1.default.flags,
    force: core_1.Flags.boolean({ description: "overwrite output file if exists" }),
    outputFile: core_1.Flags.string({
        char: "f",
        description: "output file to save aggregator pubkeys to",
        required: true,
    }),
    json: core_1.Flags.boolean({
        description: "output aggregator accounts in json format",
    }),
    csv: core_1.Flags.boolean({
        description: "output aggregator accounts in csv format",
    }),
    // txt: Flags.boolean({
    //   description: "output aggregator pubkeys in txt format",
    // }),
};
exports.default = OutputFileBaseCommand;
