"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const core_1 = require("@oclif/core");
const coder_1 = require("@project-serum/anchor/dist/cjs/coder");
const web3_js_1 = require("@solana/web3.js");
const sbv2_utils_1 = require("@switchboard-xyz/sbv2-utils");
const switchboard_v2_1 = require("@switchboard-xyz/switchboard-v2");
const chalk_1 = tslib_1.__importDefault(require("chalk"));
const path = tslib_1.__importStar(require("path"));
const types_1 = require("./types");
const logging_1 = require("./types/context/logging");
const utils_1 = require("./utils");
class PrintBaseCommand extends core_1.Command {
    async init() {
        const { flags } = (await this.parse(this.constructor));
        // this.flags = flags;
        // setup logging
        const level = flags.silent ? "error" : flags.verbose ? "debug" : "info";
        const logFilename = path.join(this.config.cacheDir, "log.txt");
        const logParameters = {
            console: {
                level,
            },
            file: {
                level: "debug",
                filename: logFilename,
            },
            silent: flags.silent,
            verbose: flags.verbose,
        };
        this.logger = new logging_1.LogProvider(logParameters);
        this.context = {
            logger: this.logger,
            fs: new types_1.FsProvider(this.config.dataDir, this.logger),
            config: this.cliConfig,
        };
        this.clusters = {
            devnet: await (0, utils_1.loadAnchor)("devnet", new web3_js_1.Connection((0, web3_js_1.clusterApiUrl)("devnet")), web3_js_1.Keypair.fromSeed(new Uint8Array(32).fill(1))),
            mainnet: await (0, utils_1.loadAnchor)("mainnet-beta", new web3_js_1.Connection((0, web3_js_1.clusterApiUrl)("mainnet-beta")), web3_js_1.Keypair.fromSeed(new Uint8Array(32).fill(1))),
        };
    }
    async printAccount(program, publicKey, accountType) {
        switch (accountType) {
            case "JobAccountData": {
                const job = new switchboard_v2_1.JobAccount({ program, publicKey });
                this.logger.log(await (0, sbv2_utils_1.prettyPrintJob)(job));
                break;
            }
            case "AggregatorAccountData": {
                const aggregator = new switchboard_v2_1.AggregatorAccount({ program, publicKey });
                this.logger.log(await (0, sbv2_utils_1.prettyPrintAggregator)(aggregator, undefined, true, true));
                break;
            }
            case "OracleAccountData": {
                const oracle = new switchboard_v2_1.OracleAccount({ program, publicKey });
                this.logger.log(await (0, sbv2_utils_1.prettyPrintOracle)(oracle, undefined, true));
                break;
            }
            case "PermissionAccountData": {
                const permission = new switchboard_v2_1.PermissionAccount({ program, publicKey });
                this.logger.log(await (0, sbv2_utils_1.prettyPrintPermissions)(permission));
                break;
            }
            case "LeaseAccountData": {
                const lease = new switchboard_v2_1.LeaseAccount({ program, publicKey });
                this.logger.log(await (0, sbv2_utils_1.prettyPrintLease)(lease));
                break;
            }
            case "OracleQueueAccountData": {
                const queue = new switchboard_v2_1.OracleQueueAccount({ program, publicKey });
                this.logger.log(await (0, sbv2_utils_1.prettyPrintQueue)(queue));
                break;
            }
            case "CrankAccountData": {
                const crank = new switchboard_v2_1.CrankAccount({ program, publicKey });
                this.logger.log(await (0, sbv2_utils_1.prettyPrintCrank)(crank));
                break;
            }
            case "SbState":
            case "ProgramStateAccountData": {
                const [programState] = switchboard_v2_1.ProgramStateAccount.fromSeed(program);
                this.logger.log(await (0, sbv2_utils_1.prettyPrintProgramState)(programState));
                break;
            }
            case "VrfAccountData": {
                const vrfAccount = new switchboard_v2_1.VrfAccount({ program, publicKey });
                this.logger.log(await (0, sbv2_utils_1.prettyPrintVrf)(vrfAccount));
                break;
            }
            case "BufferRelayerAccountData": {
                const bufferRelayerAccount = new switchboard_v2_1.BufferRelayerAccount({
                    program,
                    publicKey,
                });
                this.logger.log(await (0, sbv2_utils_1.prettyPrintBufferRelayer)(bufferRelayerAccount));
                break;
            }
            case "BUFFERxx": {
                console.log(`Found buffer account but dont know which one`);
                break;
            }
        }
    }
    // should also check if pubkey is a token account
    async printDevnetAccount(publicKey) {
        const account = await this.clusters.devnet.provider.connection.getAccountInfo(publicKey);
        if (!account) {
            throw new Error(`devnet account not found`);
        }
        const accountDiscriminator = account.data.slice(0, coder_1.ACCOUNT_DISCRIMINATOR_SIZE);
        // console.log(`[${Uint8Array.from(accountDiscriminator)}]`);
        for await (const [accountType, discriminator,] of sbv2_utils_1.SWITCHBOARD_DISCRIMINATOR_MAP.entries()) {
            if (Buffer.compare(accountDiscriminator, discriminator) === 0) {
                await this.printAccount(this.clusters.devnet, publicKey, accountType);
                return;
            }
        }
        throw new Error(`no devnet switchboard account found for ${publicKey}`);
    }
    // should also check if pubkey is a token account
    async printMainnetAccount(publicKey) {
        const account = await this.clusters.mainnet.provider.connection.getAccountInfo(publicKey);
        if (!account) {
            throw new Error(`mainnet account not found`);
        }
        const accountDiscriminator = account.data.slice(0, coder_1.ACCOUNT_DISCRIMINATOR_SIZE);
        for await (const [accountType, discriminator,] of sbv2_utils_1.SWITCHBOARD_DISCRIMINATOR_MAP.entries()) {
            if (Buffer.compare(accountDiscriminator, discriminator) === 0) {
                await this.printAccount(this.clusters.mainnet, publicKey, accountType);
                return;
            }
        }
        throw new Error(`no mainnet switchboard account found for ${publicKey}`);
    }
    async catch(error, message) {
        var _a;
        // fall back to console if logger is not initialized yet
        const logger = (_a = this.logger) !== null && _a !== void 0 ? _a : console;
        if (message) {
            logger.info(chalk_1.default.red(`${utils_1.FAILED_ICON}${message}`));
        }
        if (error.message) {
            const messageLines = error.message.split("\n");
            logger.error(messageLines[0]);
        }
        else if (error.stack) {
            logger.error(error);
        }
        else {
            logger.error(error.toString());
        }
        this.exit(1); // causes unreadable errors
    }
}
PrintBaseCommand.flags = {
    help: core_1.Flags.help({ char: "h" }),
    verbose: core_1.Flags.boolean({
        char: "v",
        description: "log everything",
        default: false,
    }),
};
exports.default = PrintBaseCommand;
