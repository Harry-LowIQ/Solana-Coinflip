"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
/* eslint-disable complexity */
/* eslint-disable unicorn/new-for-builtins */
const core_1 = require("@oclif/core");
const anchor = tslib_1.__importStar(require("@project-serum/anchor"));
const spl = tslib_1.__importStar(require("@solana/spl-token-v2"));
const web3_js_1 = require("@solana/web3.js");
const sbv2_utils_1 = require("@switchboard-xyz/sbv2-utils");
const switchboard_v2_1 = require("@switchboard-xyz/switchboard-v2");
const big_js_1 = tslib_1.__importDefault(require("big.js"));
const fs_1 = tslib_1.__importDefault(require("fs"));
const path_1 = tslib_1.__importDefault(require("path"));
const BaseCommand_1 = tslib_1.__importDefault(require("../../BaseCommand"));
const utils_1 = require("../../utils");
class QueueCreate extends BaseCommand_1.default {
    async run() {
        var _a, _b, _c;
        (0, utils_1.verifyProgramHasPayer)(this.program);
        const { flags, args } = await this.parse(QueueCreate);
        const payerKeypair = (0, switchboard_v2_1.programWallet)(this.program);
        const signers = [payerKeypair];
        const outputPath = flags.outputFile === undefined
            ? undefined
            : flags.outputFile.startsWith("/") || flags.outputFile.startsWith("C:")
                ? flags.outputFile
                : path_1.default.join(process.cwd(), flags.outputFile);
        if (outputPath && fs_1.default.existsSync(outputPath) && flags.force === false) {
            throw new Error(`output json file already exists: ${outputPath}`);
        }
        const authorityKeypair = await this.loadAuthority(flags.authority);
        if (!authorityKeypair.publicKey.equals(payerKeypair.publicKey)) {
            signers.push(authorityKeypair);
        }
        const [programStateAccount, stateBump] = switchboard_v2_1.ProgramStateAccount.fromSeed(this.program);
        const mint = await spl.getMint(this.program.provider.connection, spl.NATIVE_MINT, undefined, spl.TOKEN_PROGRAM_ID);
        const createQueueTxns = [];
        // create program state account if it doesnt exist
        try {
            await programStateAccount.loadData();
        }
        catch {
            const vaultKeypair = anchor.web3.Keypair.generate();
            createQueueTxns.push([
                web3_js_1.SystemProgram.createAccount({
                    fromPubkey: payerKeypair.publicKey,
                    newAccountPubkey: vaultKeypair.publicKey,
                    lamports: await this.program.provider.connection.getMinimumBalanceForRentExemption(spl.AccountLayout.span),
                    space: spl.AccountLayout.span,
                    programId: spl.TOKEN_PROGRAM_ID,
                }),
                spl.createInitializeAccountInstruction(vaultKeypair.publicKey, mint.address, payerKeypair.publicKey, spl.TOKEN_PROGRAM_ID),
                await this.program.methods
                    .programInit({
                    stateBump,
                })
                    .accounts({
                    state: programStateAccount.publicKey,
                    authority: payerKeypair.publicKey,
                    tokenMint: mint.address,
                    vault: vaultKeypair.publicKey,
                    payer: payerKeypair.publicKey,
                    systemProgram: web3_js_1.SystemProgram.programId,
                    tokenProgram: spl.TOKEN_PROGRAM_ID,
                    daoMint: mint.address,
                })
                    .instruction(),
            ]);
            signers.push(vaultKeypair);
        }
        const queueKeypair = anchor.web3.Keypair.generate();
        const queueBuffer = anchor.web3.Keypair.generate();
        const queueSize = flags.queueSize * 32 + 8;
        const queueAccount = new switchboard_v2_1.OracleQueueAccount({
            program: this.program,
            publicKey: queueKeypair.publicKey,
        });
        this.logger.debug((0, sbv2_utils_1.chalkString)("OracleQueue", queueKeypair.publicKey));
        this.logger.debug((0, sbv2_utils_1.chalkString)("OracleBuffer", queueBuffer.publicKey));
        createQueueTxns.push(anchor.web3.SystemProgram.createAccount({
            fromPubkey: payerKeypair.publicKey,
            newAccountPubkey: queueBuffer.publicKey,
            space: queueSize,
            lamports: await this.program.provider.connection.getMinimumBalanceForRentExemption(queueSize),
            programId: this.program.programId,
        }), await this.program.methods
            .oracleQueueInit({
            name: Buffer.from(flags.name).slice(0, 32),
            metadata: Buffer.from("").slice(0, 64),
            reward: flags.reward ? new anchor.BN(flags.reward) : new anchor.BN(0),
            minStake: flags.minStake
                ? new anchor.BN(flags.minStake)
                : new anchor.BN(0),
            feedProbationPeriod: 0,
            oracleTimeout: flags.oracleTimeout,
            slashingEnabled: false,
            varianceToleranceMultiplier: switchboard_v2_1.SwitchboardDecimal.fromBig(new big_js_1.default(2)),
            authority: authorityKeypair.publicKey,
            consecutiveFeedFailureLimit: new anchor.BN(1000),
            consecutiveOracleFailureLimit: new anchor.BN(1000),
            minimumDelaySeconds: 5,
            queueSize: flags.queueSize,
            unpermissionedFeeds: (_a = flags.unpermissionedFeeds) !== null && _a !== void 0 ? _a : false,
            unpermissionedVrf: (_b = flags.unpermissionedVrf) !== null && _b !== void 0 ? _b : false,
            enableBufferRelayers: (_c = flags.enableBufferRelayers) !== null && _c !== void 0 ? _c : false,
        })
            .accounts({
            oracleQueue: queueKeypair.publicKey,
            authority: authorityKeypair.publicKey,
            buffer: queueBuffer.publicKey,
            systemProgram: web3_js_1.SystemProgram.programId,
            payer: payerKeypair.publicKey,
            mint: mint.address,
        })
            .instruction());
        signers.push(queueKeypair, queueBuffer);
        // add crank txns
        const setupQueueTxns = [];
        let crankAccount;
        if (flags.crankSize) {
            const crankKeypair = anchor.web3.Keypair.generate();
            const crankBuffer = anchor.web3.Keypair.generate();
            const crankSize = flags.crankSize ? flags.crankSize * 40 + 8 : 0;
            this.logger.debug((0, sbv2_utils_1.chalkString)("CrankAccount", crankKeypair.publicKey));
            this.logger.debug((0, sbv2_utils_1.chalkString)("CrankBuffer", crankBuffer.publicKey));
            crankAccount = new switchboard_v2_1.CrankAccount({
                program: this.program,
                publicKey: crankKeypair.publicKey,
            });
            signers.push(crankKeypair, crankBuffer);
            setupQueueTxns.push(anchor.web3.SystemProgram.createAccount({
                fromPubkey: payerKeypair.publicKey,
                newAccountPubkey: crankBuffer.publicKey,
                space: crankSize,
                lamports: await this.program.provider.connection.getMinimumBalanceForRentExemption(crankSize),
                programId: this.program.programId,
            }), await this.program.methods
                .crankInit({
                name: Buffer.from("Crank").slice(0, 32),
                metadata: Buffer.from("").slice(0, 64),
                crankSize: flags.crankSize,
            })
                .accounts({
                crank: crankKeypair.publicKey,
                queue: queueKeypair.publicKey,
                buffer: crankBuffer.publicKey,
                systemProgram: web3_js_1.SystemProgram.programId,
                payer: payerKeypair.publicKey,
            })
                .instruction());
        }
        // create any oracles
        const createOracleIxns = [];
        const oracleAccounts = await Promise.all([...Array(flags.numOracles).keys()].map(async (n) => {
            const name = `Oracle-${n + 1}`;
            const tokenWalletKeypair = anchor.web3.Keypair.generate();
            const [oracleAccount, oracleBump] = switchboard_v2_1.OracleAccount.fromSeed(this.program, queueAccount, tokenWalletKeypair.publicKey);
            this.logger.debug((0, sbv2_utils_1.chalkString)(name, oracleAccount.publicKey));
            const [permissionAccount, permissionBump] = switchboard_v2_1.PermissionAccount.fromSeed(this.program, authorityKeypair.publicKey, queueAccount.publicKey, oracleAccount.publicKey);
            this.logger.debug((0, sbv2_utils_1.chalkString)(`Permission-${n + 1}`, permissionAccount.publicKey));
            createOracleIxns.push([
                web3_js_1.SystemProgram.createAccount({
                    fromPubkey: payerKeypair.publicKey,
                    newAccountPubkey: tokenWalletKeypair.publicKey,
                    lamports: await this.program.provider.connection.getMinimumBalanceForRentExemption(spl.AccountLayout.span),
                    space: spl.AccountLayout.span,
                    programId: spl.TOKEN_PROGRAM_ID,
                }),
                spl.createInitializeAccountInstruction(tokenWalletKeypair.publicKey, mint.address, programStateAccount.publicKey, spl.TOKEN_PROGRAM_ID),
                await this.program.methods
                    .oracleInit({
                    name: Buffer.from(name).slice(0, 32),
                    metadata: Buffer.from("").slice(0, 128),
                    stateBump,
                    oracleBump,
                })
                    .accounts({
                    oracle: oracleAccount.publicKey,
                    oracleAuthority: authorityKeypair.publicKey,
                    queue: queueKeypair.publicKey,
                    wallet: tokenWalletKeypair.publicKey,
                    programState: programStateAccount.publicKey,
                    systemProgram: web3_js_1.SystemProgram.programId,
                    payer: payerKeypair.publicKey,
                })
                    .instruction(),
                await this.program.methods
                    .permissionInit({})
                    .accounts({
                    permission: permissionAccount.publicKey,
                    authority: authorityKeypair.publicKey,
                    granter: queueAccount.publicKey,
                    grantee: oracleAccount.publicKey,
                    payer: payerKeypair.publicKey,
                    systemProgram: web3_js_1.SystemProgram.programId,
                })
                    .instruction(),
                await this.program.methods
                    .permissionSet({
                    // eslint-disable-next-line unicorn/no-null
                    permission: { permitOracleHeartbeat: null },
                    enable: true,
                })
                    .accounts({
                    permission: permissionAccount.publicKey,
                    authority: authorityKeypair.publicKey,
                })
                    .instruction(),
            ]);
            signers.push(tokenWalletKeypair);
            return {
                oracleAccount,
                name,
                permissionAccount,
                tokenWalletKeypair,
            };
        }));
        const ixnBatches = [createQueueTxns];
        if (setupQueueTxns.length > 0) {
            ixnBatches.push(setupQueueTxns);
        }
        if (createOracleIxns.length > 0) {
            ixnBatches.push(createOracleIxns);
        }
        const createAccountSignatures = (0, sbv2_utils_1.packAndSend)(this.program, ixnBatches, signers, payerKeypair.publicKey).catch((error) => {
            this.logger.error(error);
            throw error;
        });
        let queueWs;
        const queueInitPromise = new Promise((resolve) => {
            queueWs = this.program.provider.connection.onAccountChange(queueKeypair.publicKey, (accountInfo, slot) => {
                const queueData = new anchor.BorshAccountsCoder(this.program.idl).decode("OracleQueueAccountData", accountInfo.data);
                resolve(queueData);
            });
        });
        const result = await (0, sbv2_utils_1.promiseWithTimeout)(45000, queueInitPromise).finally(() => {
            try {
                this.program.provider.connection.removeAccountChangeListener(queueWs);
            }
            catch { }
        });
        let queueData;
        try {
            queueData = await queueAccount.loadData();
        }
        catch (error) {
            this.logger.error(error);
            throw error;
        }
        if (outputPath) {
            fs_1.default.mkdirSync(path_1.default.dirname(outputPath), { recursive: true });
            fs_1.default.writeFileSync(outputPath, JSON.stringify({
                name: flags.name,
                queueAccount: queueKeypair.publicKey.toString(),
                queueSize: flags.queueSize,
                queueReward: Number.parseInt(flags.reward, 10),
                minStake: Number.parseInt(flags.minStake, 10),
                oracleTimeout: flags.oracleTimeout,
                // crankAccount === undefined ? undefined :
                crankAccounts: crankAccount === undefined
                    ? undefined
                    : [
                        {
                            name: "Crank",
                            crankAccount: crankAccount.publicKey.toString(),
                            maxRows: flags.crankSize,
                        },
                    ],
                oracleAccounts: [
                    oracleAccounts.map((oracle) => {
                        return {
                            name: oracle.name,
                            oracleAccount: oracle.oracleAccount.publicKey.toString(),
                            tokenWallet: oracle.tokenWalletKeypair.publicKey.toString(),
                            permissionAccount: oracle.permissionAccount.publicKey.toString(),
                        };
                    }),
                ],
            }, undefined, 2));
        }
        if (this.silent) {
            console.log(queueAccount.publicKey.toString());
            return;
        }
        try {
            this.logger.info("\r\n" + (await (0, sbv2_utils_1.prettyPrintQueue)(queueAccount, queueData, false)));
        }
        catch { }
        try {
            this.logger.info(await (0, sbv2_utils_1.prettyPrintCrank)(crankAccount, undefined, false, 30));
        }
        catch { }
        for await (const oracle of oracleAccounts) {
            try {
                this.logger.info(await (0, sbv2_utils_1.prettyPrintOracle)(oracle.oracleAccount, undefined, true, 30));
            }
            catch { }
        }
    }
    async catch(error) {
        super.catch(error, "Failed to create custom queue");
    }
}
exports.default = QueueCreate;
QueueCreate.description = "create a custom queue";
QueueCreate.aliases = ["custom:queue"];
QueueCreate.flags = {
    ...BaseCommand_1.default.flags,
    force: core_1.Flags.boolean({
        description: "overwrite output file if existing",
        default: false,
    }),
    authority: core_1.Flags.string({
        char: "a",
        description: "keypair to delegate authority to for creating permissions targeted at the queue",
    }),
    name: core_1.Flags.string({
        char: "n",
        description: "name of the queue for easier identification",
        default: "Custom Queue",
    }),
    minStake: core_1.Flags.string({
        description: "minimum stake required by an oracle to join the queue",
        default: "0",
    }),
    reward: core_1.Flags.string({
        char: "r",
        description: "oracle rewards for successfully responding to an update request",
        default: "0",
    }),
    crankSize: core_1.Flags.integer({
        char: "c",
        description: "size of the crank",
        default: 100,
    }),
    oracleTimeout: core_1.Flags.integer({
        description: "number of oracles to add to the queue",
        default: 180,
    }),
    numOracles: core_1.Flags.integer({
        char: "o",
        description: "number of oracles to add to the queue",
    }),
    queueSize: core_1.Flags.integer({
        description: "maximum number of oracles the queue can support",
        default: 100,
    }),
    unpermissionedFeeds: core_1.Flags.boolean({
        description: "permit unpermissioned feeds",
        default: false,
    }),
    unpermissionedVrf: core_1.Flags.boolean({
        description: "permit unpermissioned VRF accounts",
        default: false,
    }),
    enableBufferRelayers: core_1.Flags.boolean({
        description: "enable oracles to fulfill buffer relayer requests",
        default: false,
    }),
    outputFile: core_1.Flags.string({
        char: "f",
        description: "output queue schema to a json file",
        required: false,
    }),
};
