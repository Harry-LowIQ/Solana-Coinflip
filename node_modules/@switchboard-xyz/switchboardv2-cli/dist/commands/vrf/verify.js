"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const web3_js_1 = require("@solana/web3.js");
const sbv2_utils_1 = require("@switchboard-xyz/sbv2-utils");
const switchboard_v2_1 = require("@switchboard-xyz/switchboard-v2");
const BaseCommand_1 = tslib_1.__importDefault(require("../../BaseCommand"));
class VrfVerify extends BaseCommand_1.default {
    async run() {
        const { args, flags } = await this.parse(VrfVerify);
        (0, sbv2_utils_1.verifyProgramHasPayer)(this.program);
        const payerKeypair = (0, switchboard_v2_1.programWallet)(this.program);
        const vrfAccount = new switchboard_v2_1.VrfAccount({
            program: this.program,
            publicKey: new web3_js_1.PublicKey(args.vrfKey),
        });
        const vrf = await vrfAccount.loadData();
        const status = (0, sbv2_utils_1.toVrfStatusString)(vrf.status);
        if (status !== "StatusVerifying") {
            throw new Error(`Vrf not ready to be verified, current status ${status}`);
        }
        if (vrf.txRemaining === 0) {
            throw new Error(`vrf has ${vrf.txRemaining} txRemaining to verify proof`);
        }
        const oracle = new switchboard_v2_1.OracleAccount({
            program: this.program,
            publicKey: vrf.builders[0].producer,
        });
        const signatures = await vrfAccount.verify(oracle);
        this.log(`VrfAccount verification instructions sent\r\n${JSON.stringify(signatures, undefined, 2)}`);
    }
}
exports.default = VrfVerify;
VrfVerify.description = "if ready, verify a VRF proof";
VrfVerify.examples = [];
VrfVerify.flags = {
    ...BaseCommand_1.default.flags,
};
VrfVerify.args = [
    {
        name: "vrfKey",
        description: "public key of the VRF account to request randomness for",
    },
];
