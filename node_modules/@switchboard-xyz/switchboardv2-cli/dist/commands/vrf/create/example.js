"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const core_1 = require("@oclif/core");
const anchor = tslib_1.__importStar(require("@project-serum/anchor"));
const spl = tslib_1.__importStar(require("@solana/spl-token-v2"));
const web3_js_1 = require("@solana/web3.js");
const sbv2_utils_1 = require("@switchboard-xyz/sbv2-utils");
const switchboard_v2_1 = require("@switchboard-xyz/switchboard-v2");
const BaseCommand_1 = tslib_1.__importDefault(require("../../../BaseCommand"));
const utils_1 = require("../../../utils");
class VrfCreateExample extends BaseCommand_1.default {
    async run() {
        const { args, flags } = await this.parse(VrfCreateExample);
        (0, utils_1.verifyProgramHasPayer)(this.program);
        const payerKeypair = (0, switchboard_v2_1.programWallet)(this.program);
        this.mainnetCheck();
        // load VRF params
        const vrfSecret = flags.vrfKeypair
            ? await (0, utils_1.loadKeypair)(flags.vrfKeypair)
            : anchor.web3.Keypair.generate();
        const queueAuthority = flags.queueAuthority
            ? await (0, utils_1.loadKeypair)(flags.queueAuthority)
            : payerKeypair;
        // load VRF client program
        const vrfProgramId = new web3_js_1.PublicKey(flags.vrfPid);
        const vrfExampleIdl = await anchor.Program.fetchIdl(vrfProgramId, this.program.provider);
        if (!vrfExampleIdl) {
            throw new Error(`failed to read VRF Example program idl for ${this.cluster} ${vrfProgramId}`);
        }
        const vrfclientProgram = new anchor.Program(vrfExampleIdl, vrfProgramId, this.program.provider);
        // load client for callback
        const ixCoder = new anchor.BorshInstructionCoder(vrfclientProgram.idl);
        const [clientPubkey, clientBump] = anchor.utils.publicKey.findProgramAddressSync([
            Buffer.from("STATE"),
            vrfSecret.publicKey.toBytes(),
            payerKeypair.publicKey.toBytes(),
        ], vrfclientProgram.programId);
        const callback = {
            programId: vrfclientProgram.programId,
            accounts: [
                // ensure all accounts in updateResult are populated
                { pubkey: clientPubkey, isSigner: false, isWritable: true },
                { pubkey: vrfSecret.publicKey, isSigner: false, isWritable: false },
            ],
            ixData: ixCoder.encode("updateResult", ""), // pass any params for instruction here
        };
        // load Switchboard accounts
        const [programStateAccount, stateBump] = switchboard_v2_1.ProgramStateAccount.fromSeed(this.program);
        const queueAccount = new switchboard_v2_1.OracleQueueAccount({
            program: this.program,
            publicKey: new web3_js_1.PublicKey(args.queueKey),
        });
        const queue = await queueAccount.loadData();
        const mint = await queueAccount.loadMint();
        const vrfEscrowPubkey = await spl.getAssociatedTokenAddress(mint.address, vrfSecret.publicKey, true, spl.TOKEN_PROGRAM_ID, spl.ASSOCIATED_TOKEN_PROGRAM_ID);
        const [permissionAccount, permissionBump] = switchboard_v2_1.PermissionAccount.fromSeed(this.program, queue.authority, queueAccount.publicKey, vrfSecret.publicKey);
        // create account txns
        const createTxn = new web3_js_1.Transaction();
        createTxn.add(spl.createAssociatedTokenAccountInstruction(payerKeypair.publicKey, vrfEscrowPubkey, vrfSecret.publicKey, mint.address, spl.TOKEN_PROGRAM_ID, spl.ASSOCIATED_TOKEN_PROGRAM_ID), spl.createSetAuthorityInstruction(vrfEscrowPubkey, vrfSecret.publicKey, spl.AuthorityType.AccountOwner, programStateAccount.publicKey, [payerKeypair, vrfSecret], spl.TOKEN_PROGRAM_ID), web3_js_1.SystemProgram.createAccount({
            fromPubkey: payerKeypair.publicKey,
            newAccountPubkey: vrfSecret.publicKey,
            space: this.program.account.vrfAccountData.size,
            lamports: await this.program.provider.connection.getMinimumBalanceForRentExemption(this.program.account.vrfAccountData.size),
            programId: this.program.programId,
        }), await this.program.methods
            .vrfInit({
            stateBump,
            callback,
        })
            .accounts({
            vrf: vrfSecret.publicKey,
            escrow: vrfEscrowPubkey,
            authority: clientPubkey,
            oracleQueue: queueAccount.publicKey,
            programState: programStateAccount.publicKey,
            tokenProgram: spl.TOKEN_PROGRAM_ID,
        })
            .instruction(), await this.program.methods
            .permissionInit({})
            .accounts({
            permission: permissionAccount.publicKey,
            authority: queue.authority,
            granter: queueAccount.publicKey,
            grantee: vrfSecret.publicKey,
            payer: payerKeypair.publicKey,
            systemProgram: web3_js_1.SystemProgram.programId,
        })
            .instruction());
        // if flag, enable permissions
        if (flags.enable) {
            if (!queueAuthority.publicKey.equals(queue.authority)) {
                throw new Error(`Invalid queue authority, received ${queueAuthority.publicKey}, expected ${queue.authority}`);
            }
            createTxn.add(await this.program.methods
                .permissionSet({
                permission: { permitVrfRequests: undefined },
                enable: true,
            })
                .accounts({
                permission: permissionAccount.publicKey,
                authority: queue.authority,
            })
                .instruction());
        }
        // create client program account
        createTxn.add(await vrfclientProgram.methods
            .initState({
            maxResult: new anchor.BN(flags.maxResult),
        })
            .accounts({
            state: clientPubkey,
            vrf: vrfSecret.publicKey,
            payer: payerKeypair.publicKey,
            authority: payerKeypair.publicKey,
            systemProgram: web3_js_1.SystemProgram.programId,
        })
            .instruction());
        // send transaction
        const signature = await this.program.provider.sendAndConfirm(createTxn, [payerKeypair, vrfSecret, queueAuthority], { commitment: "finalized" });
        if (this.silent) {
            console.log(vrfSecret.publicKey.toString());
            return;
        }
        await (0, utils_1.sleep)(2000);
        this.logger.log(`https://explorer.solana.com/tx/${signature}?cluster=${this.cluster}`);
        this.logger.log(await (0, sbv2_utils_1.prettyPrintVrf)(new switchboard_v2_1.VrfAccount({
            program: this.program,
            publicKey: vrfSecret.publicKey,
        }), undefined, true));
    }
}
exports.default = VrfCreateExample;
VrfCreateExample.description = "create a VRF account for the client example program";
VrfCreateExample.examples = [
    "sbv2 vrf:create:example 9WZ59yz95bd3XwJxDPVE2PjvVWmSy9WM1NgGD2Hqsohw --vrfPid 6MLk7G54uHZ7JuzNxpBAVENANrgM9BZ51pKkzGwPYBCE --keypair ../payer-keypair.json -v --enable --queueAuthority queue-authority-keypair.json",
];
VrfCreateExample.flags = {
    ...BaseCommand_1.default.flags,
    vrfPid: core_1.Flags.string({
        description: "program ID for the VRF example program",
        required: true,
    }),
    vrfKeypair: core_1.Flags.string({
        description: "filesystem path of existing keypair to use for VRF Account",
    }),
    enable: core_1.Flags.boolean({
        description: "enable vrf permissions",
    }),
    queueAuthority: core_1.Flags.string({
        description: "alternative keypair to use for queue authority",
    }),
    maxResult: core_1.Flags.string({
        description: "the maximum VRF result",
        default: "256000",
    }),
};
VrfCreateExample.args = [
    {
        name: "queueKey",
        description: "public key of the oracle queue to create VRF account for",
    },
];
