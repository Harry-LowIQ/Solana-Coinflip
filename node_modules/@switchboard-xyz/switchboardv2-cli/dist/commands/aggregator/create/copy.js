"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
/* eslint-disable unicorn/no-array-push-push */
const core_1 = require("@oclif/core");
const anchor = tslib_1.__importStar(require("@project-serum/anchor"));
const spl = tslib_1.__importStar(require("@solana/spl-token-v2"));
const web3_js_1 = require("@solana/web3.js");
const sbv2_utils_1 = require("@switchboard-xyz/sbv2-utils");
const switchboard_v2_1 = require("@switchboard-xyz/switchboard-v2");
const big_js_1 = tslib_1.__importDefault(require("big.js"));
const BaseCommand_1 = tslib_1.__importDefault(require("../../../BaseCommand"));
// TODO: Fix command so it accepts a feed authority flag
// TODO: Add flag that skips job creation
class AggregatorCreateCopy extends BaseCommand_1.default {
    async run() {
        var _a, _b, _c, _d, _e;
        (0, sbv2_utils_1.verifyProgramHasPayer)(this.program);
        const { args, flags } = await this.parse(AggregatorCreateCopy);
        const payerKeypair = (0, switchboard_v2_1.programWallet)(this.program);
        const feedAuthority = await this.loadAuthority(flags.authority);
        const queueAuthority = await this.loadAuthority(flags.queueAuthority);
        // const sourceProgram = !flags.sourceCluster
        //   ? this.program
        //   : flags.sourceCluster === "devnet" ||
        //     flags.sourceCluster === "mainnet-beta"
        //   ? await loadSwitchboardProgram(
        //       flags.sourceCluster,
        //       undefined,
        //       payerKeypair
        //     )
        //   : undefined;
        const sourceProgram = this.program;
        if (sourceProgram === undefined) {
            throw new Error(`Invalid sourceAggregatorCluster`);
        }
        const sourceAggregatorAccount = new switchboard_v2_1.AggregatorAccount({
            program: sourceProgram,
            publicKey: args.aggregatorSource,
        });
        const sourceAggregator = await sourceAggregatorAccount.loadData();
        const sourceJobPubkeys = sourceAggregator.jobPubkeysData.slice(0, sourceAggregator.jobPubkeysSize);
        const sourceJobAccounts = sourceJobPubkeys.map((publicKey) => {
            return new switchboard_v2_1.JobAccount({ program: sourceProgram, publicKey: publicKey });
        });
        const [programStateAccount, stateBump] = switchboard_v2_1.ProgramStateAccount.fromSeed(this.program);
        const programState = await programStateAccount.loadData();
        const queueAccount = new switchboard_v2_1.OracleQueueAccount({
            program: this.program,
            publicKey: new web3_js_1.PublicKey(flags.queueKey),
        });
        const queue = await queueAccount.loadData();
        const mint = await queueAccount.loadMint();
        const tokenWallet = (await spl.getOrCreateAssociatedTokenAccount(this.program.provider.connection, payerKeypair, mint.address, payerKeypair.publicKey, undefined, undefined, undefined, spl.TOKEN_PROGRAM_ID, spl.ASSOCIATED_TOKEN_PROGRAM_ID)).address;
        const createAccountInstructions = [];
        const createAccountSigners = [
            payerKeypair,
            feedAuthority,
            queueAuthority,
        ];
        // Create Aggregator & Permissions
        const aggregatorKeypair = web3_js_1.Keypair.generate();
        this.logger.debug(`Aggregator: ${aggregatorKeypair.publicKey}`);
        createAccountSigners.push(aggregatorKeypair);
        const aggregatorSize = this.program.account.aggregatorAccountData.size;
        const [permissionAccount, permissionBump] = switchboard_v2_1.PermissionAccount.fromSeed(this.program, queue.authority, queueAccount.publicKey, aggregatorKeypair.publicKey);
        const aggregatorAccount = new switchboard_v2_1.AggregatorAccount({
            program: this.program,
            publicKey: aggregatorKeypair.publicKey,
        });
        // Create lease and push to crank
        const [leaseAccount, leaseBump] = switchboard_v2_1.LeaseAccount.fromSeed(this.program, queueAccount, aggregatorAccount);
        const leaseEscrow = await spl.getAssociatedTokenAddress(mint.address, leaseAccount.publicKey, true);
        createAccountInstructions.push([
            // allocate aggregator space
            web3_js_1.SystemProgram.createAccount({
                fromPubkey: payerKeypair.publicKey,
                newAccountPubkey: aggregatorKeypair.publicKey,
                space: aggregatorSize,
                lamports: await this.program.provider.connection.getMinimumBalanceForRentExemption(aggregatorSize),
                programId: this.program.programId,
            }),
            // create aggregator
            await this.program.methods
                .aggregatorInit({
                name: sourceAggregator.name,
                metadata: sourceAggregator.metadata,
                batchSize: (_a = flags.batchSize) !== null && _a !== void 0 ? _a : sourceAggregator.oracleRequestBatchSize,
                minOracleResults: (_b = flags.minOracles) !== null && _b !== void 0 ? _b : sourceAggregator.minOracleResults,
                minJobResults: (_c = flags.minJobs) !== null && _c !== void 0 ? _c : sourceAggregator.minJobResults,
                minUpdateDelaySeconds: (_d = flags.minUpdateDelay) !== null && _d !== void 0 ? _d : sourceAggregator.minUpdateDelaySeconds,
                varianceThreshold: flags.varianceThreshold
                    ? switchboard_v2_1.SwitchboardDecimal.fromBig(new big_js_1.default(flags.varianceThreshold))
                    : sourceAggregator.varianceThreshold,
                forceReportPeriod: (_e = flags.forceReportPeriod) !== null && _e !== void 0 ? _e : sourceAggregator.forceReportPeriod,
                stateBump,
            })
                .accounts({
                aggregator: aggregatorKeypair.publicKey,
                authority: feedAuthority.publicKey,
                queue: queueAccount.publicKey,
                authorWallet: tokenWallet,
                programState: programStateAccount.publicKey,
            })
                .instruction(),
            // create permissions
            await this.program.methods
                .permissionInit({})
                .accounts({
                permission: permissionAccount.publicKey,
                authority: queue.authority,
                granter: queueAccount.publicKey,
                grantee: aggregatorKeypair.publicKey,
                payer: payerKeypair.publicKey,
                systemProgram: web3_js_1.SystemProgram.programId,
            })
                .instruction(),
            flags.enable && queueAuthority.publicKey.equals(queue.authority)
                ? await this.program.methods
                    .permissionSet({
                    permission: { permitOracleQueueUsage: undefined },
                    enable: true,
                })
                    .accounts({
                    permission: permissionAccount.publicKey,
                    authority: queueAuthority.publicKey,
                })
                    .instruction()
                : undefined,
        ].filter((item) => item));
        createAccountInstructions.push([
            spl.createAssociatedTokenAccountInstruction(payerKeypair.publicKey, leaseEscrow, leaseAccount.publicKey, mint.address, spl.TOKEN_PROGRAM_ID, spl.ASSOCIATED_TOKEN_PROGRAM_ID),
            await this.program.methods
                .leaseInit({
                loadAmount: new anchor.BN(0),
                stateBump,
                leaseBump,
                withdrawAuthority: feedAuthority.publicKey,
                walletBumps: Buffer.from([]),
            })
                .accounts({
                programState: programStateAccount.publicKey,
                lease: leaseAccount.publicKey,
                queue: queueAccount.publicKey,
                aggregator: aggregatorAccount.publicKey,
                systemProgram: web3_js_1.SystemProgram.programId,
                funder: tokenWallet,
                payer: payerKeypair.publicKey,
                tokenProgram: spl.TOKEN_PROGRAM_ID,
                escrow: leaseEscrow,
                owner: payerKeypair.publicKey,
                mint: mint.address,
            })
                // .remainingAccounts(
                //   jobPubkeys.concat(jobWallets).map((pubkey: PublicKey) => {
                //     return { isSigner: false, isWritable: true, pubkey };
                //   })
                // )
                .instruction(),
            flags.crankKey
                ? await this.program.methods
                    .crankPush({
                    stateBump,
                    permissionBump,
                    nofitiRef: null,
                    notifiRef: null,
                })
                    .accounts({
                    crank: new web3_js_1.PublicKey(flags.crankKey),
                    aggregator: aggregatorKeypair.publicKey,
                    oracleQueue: queueAccount.publicKey,
                    queueAuthority: queue.authority,
                    permission: permissionAccount.publicKey,
                    lease: leaseAccount.publicKey,
                    escrow: leaseEscrow,
                    programState: programStateAccount.publicKey,
                    dataBuffer: (await new switchboard_v2_1.CrankAccount({
                        program: this.program,
                        publicKey: new web3_js_1.PublicKey(flags.crankKey),
                    }).loadData()).dataBuffer,
                })
                    .instruction()
                : undefined,
        ].filter((item) => item));
        const createJobIxns = flags.copyJobs
            ? // create job account copies
                await Promise.all(sourceJobAccounts.map(async (jobAccount) => {
                    var _a, _b, _c, _d, _e;
                    const jobKeypair = web3_js_1.Keypair.generate();
                    createAccountSigners.push(jobKeypair); // add signers
                    const job = await jobAccount.loadData();
                    const data = await jobAccount.loadData();
                    const jobData = Buffer.from(switchboard_v2_1.OracleJob.encodeDelimited(switchboard_v2_1.OracleJob.create({
                        tasks: job.tasks,
                    })).finish());
                    const size = 280 + jobData.length + ((_c = (_b = (_a = data.variables) === null || _a === void 0 ? void 0 : _a.join("")) === null || _b === void 0 ? void 0 : _b.length) !== null && _c !== void 0 ? _c : 0);
                    return [
                        web3_js_1.SystemProgram.createAccount({
                            fromPubkey: payerKeypair.publicKey,
                            newAccountPubkey: jobKeypair.publicKey,
                            space: size,
                            lamports: await this.program.provider.connection.getMinimumBalanceForRentExemption(size),
                            programId: this.program.programId,
                        }),
                        await this.program.methods
                            .jobInit({
                            name: Buffer.from(data.name),
                            data: jobData,
                            variables: (_e = (_d = data.variables) === null || _d === void 0 ? void 0 : _d.map((item) => Buffer.from(""))) !== null && _e !== void 0 ? _e : new Array(),
                            authorWallet: payerKeypair.publicKey,
                            stateBump,
                        })
                            .accounts({
                            job: jobKeypair.publicKey,
                            authorWallet: tokenWallet,
                            authority: feedAuthority.publicKey,
                            programState: programStateAccount.publicKey,
                        })
                            .signers([feedAuthority])
                            .instruction(),
                        await this.program.methods
                            .aggregatorAddJob({
                            weight: 1,
                        })
                            .accounts({
                            aggregator: aggregatorKeypair.publicKey,
                            authority: feedAuthority.publicKey,
                            job: jobAccount.publicKey,
                        })
                            .instruction(),
                    ];
                }))
            : // add job by pubkey
                await Promise.all(sourceJobAccounts.map(async (jobAccount) => {
                    const addJobIxn = await this.program.methods
                        .aggregatorAddJob({
                        weight: 1,
                    })
                        .accounts({
                        aggregator: aggregatorKeypair.publicKey,
                        authority: feedAuthority.publicKey,
                        job: jobAccount.publicKey,
                    })
                        .instruction();
                    return addJobIxn;
                }));
        const createAccountSignatures = (0, sbv2_utils_1.packAndSend)(this.program, [createAccountInstructions, createJobIxns], createAccountSigners, payerKeypair.publicKey).catch((error) => {
            throw error;
        });
        let aggInitWs;
        const aggInitPromise = new Promise((resolve) => {
            aggInitWs = this.program.provider.connection.onAccountChange(aggregatorKeypair.publicKey, (accountInfo, slot) => {
                const aggData = new anchor.BorshAccountsCoder(this.program.idl).decode("AggregatorAccountData", accountInfo.data);
                resolve(aggData);
            });
        });
        const result = await (0, sbv2_utils_1.promiseWithTimeout)(45000, aggInitPromise).finally(() => {
            try {
                this.program.provider.connection.removeAccountChangeListener(aggInitWs);
            }
            catch { }
        });
        if (this.silent) {
            console.log(aggregatorAccount.publicKey.toString());
            return;
        }
        this.logger.info(await (0, sbv2_utils_1.prettyPrintAggregator)(aggregatorAccount, result, true, true, true));
    }
    async catch(error) {
        super.catch(error, "Failed to copy aggregator account to new queue");
    }
}
exports.default = AggregatorCreateCopy;
AggregatorCreateCopy.description = "copy an aggregator account to a new oracle queue";
AggregatorCreateCopy.flags = {
    ...BaseCommand_1.default.flags,
    authority: core_1.Flags.string({
        char: "a",
        description: "alternate keypair that will be the aggregator authority",
    }),
    minOracles: core_1.Flags.integer({
        description: "override source aggregator's minOracleResults",
    }),
    batchSize: core_1.Flags.integer({
        description: "override source aggregator's oracleRequestBatchSize",
    }),
    minJobs: core_1.Flags.integer({
        description: "override source aggregator's minJobResults",
    }),
    minUpdateDelay: core_1.Flags.integer({
        description: "override source aggregator's minUpdateDelaySeconds",
    }),
    forceReportPeriod: core_1.Flags.integer({
        description: "override source aggregator's forceReportPeriod",
    }),
    varianceThreshold: core_1.Flags.string({
        description: "override source aggregator's varianceThreshold",
    }),
    queueKey: core_1.Flags.string({
        description: "public key of the queue to create aggregator for",
        required: true,
    }),
    crankKey: core_1.Flags.string({
        description: "public key of the crank to push aggregator to",
        required: false,
    }),
    enable: core_1.Flags.boolean({
        description: "set permissions to PERMIT_ORACLE_QUEUE_USAGE",
    }),
    queueAuthority: core_1.Flags.string({
        description: "alternative keypair to use for queue authority",
    }),
    copyJobs: core_1.Flags.boolean({
        description: "create copy of job accounts instead of referincing existing job account",
    }),
    // sourceCluster: Flags.string({
    //   description: "alternative solana cluster to copy source aggregator from",
    //   required: false,
    //   options: ["devnet", "mainnet-beta"],
    // }),
};
AggregatorCreateCopy.args = [
    {
        name: "aggregatorSource",
        description: "public key of the aggregator account to copy",
    },
];
AggregatorCreateCopy.examples = [
    "$ sbv2 aggregator:create:copy GvDMxPzN1sCj7L26YDK2HnMRXEQmQ2aemov8YBtPS7vR --queueKey 9WZ59yz95bd3XwJxDPVE2PjvVWmSy9WM1NgGD2Hqsohw --keypair ../payer-keypair.json",
    "$ sbv2 aggregator:create:copy GvDMxPzN1sCj7L26YDK2HnMRXEQmQ2aemov8YBtPS7vR --queueKey 9WZ59yz95bd3XwJxDPVE2PjvVWmSy9WM1NgGD2Hqsohw --keypair ../payer-keypair.json --sourceCluster mainnet-beta",
    "$ sbv2 aggregator:create:copy FcSmdsdWks75YdyCGegRqXdt5BiNGQKxZywyzb8ckD7D --queueKey 9WZ59yz95bd3XwJxDPVE2PjvVWmSy9WM1NgGD2Hqsohw --keypair ../payer-keypair.json --sourceCluster mainnet-beta",
];
