"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
/* eslint-disable complexity */
const core_1 = require("@oclif/core");
const anchor = tslib_1.__importStar(require("@project-serum/anchor"));
const web3_js_1 = require("@solana/web3.js");
const sbv2_utils_1 = require("@switchboard-xyz/sbv2-utils");
const switchboard_v2_1 = require("@switchboard-xyz/switchboard-v2");
const chalk_1 = tslib_1.__importDefault(require("chalk"));
const fs = tslib_1.__importStar(require("fs"));
const path = tslib_1.__importStar(require("path"));
const BaseCommand_1 = tslib_1.__importDefault(require("../../../BaseCommand"));
const utils_1 = require("../../../utils");
class JsonCreateAggregator extends BaseCommand_1.default {
    async run() {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        const { args, flags } = await this.parse(JsonCreateAggregator);
        (0, sbv2_utils_1.verifyProgramHasPayer)(this.program);
        const payerKeypair = (0, switchboard_v2_1.programWallet)(this.program);
        const definitionFile = args.definitionFile.startsWith("/")
            ? args.definitionFile
            : path.join(process.cwd(), args.definitionFile);
        if (!fs.existsSync(definitionFile)) {
            throw new Error("input file does not exist");
        }
        const aggregatorDefinition = JSON.parse(fs.readFileSync(definitionFile, "utf-8"), utils_1.pubKeyReviver);
        let authority = (0, switchboard_v2_1.programWallet)(this.program);
        if (flags.authority) {
            authority = await (0, utils_1.loadKeypair)(flags.authority);
        }
        if (!aggregatorDefinition.queuePublicKey && !flags.queueKey) {
            throw new Error("you must provide a --queueKey to create aggregator for");
        }
        const queueAccount = new switchboard_v2_1.OracleQueueAccount({
            program: this.program,
            publicKey: aggregatorDefinition.queuePublicKey
                ? new web3_js_1.PublicKey(aggregatorDefinition.queuePublicKey)
                : new web3_js_1.PublicKey(flags.queueKey),
        });
        const authorWallet = (_a = aggregatorDefinition.authorWalletPublicKey) !== null && _a !== void 0 ? _a : payerKeypair.publicKey;
        const authorityPubkey = (_b = authority.publicKey) !== null && _b !== void 0 ? _b : payerKeypair.publicKey;
        const batchSize = (_c = aggregatorDefinition.oracleRequestBatchSize) !== null && _c !== void 0 ? _c : 3;
        const expiration = aggregatorDefinition.expiration
            ? new anchor.BN(aggregatorDefinition.expiration)
            : new anchor.BN(0);
        const forceReportPeriod = aggregatorDefinition.forceReportPeriod
            ? new anchor.BN(aggregatorDefinition.forceReportPeriod)
            : new anchor.BN(0);
        const metadata = aggregatorDefinition.metadata
            ? Buffer.from(aggregatorDefinition.metadata)
            : Buffer.from("");
        const minRequiredJobResults = (_d = aggregatorDefinition.minRequiredJobResults) !== null && _d !== void 0 ? _d : 1;
        const minRequiredOracleResults = (_e = aggregatorDefinition.minRequiredOracleResults) !== null && _e !== void 0 ? _e : 2;
        const minUpdateDelaySeconds = (_f = aggregatorDefinition.minUpdateDelaySeconds) !== null && _f !== void 0 ? _f : 30;
        const name = aggregatorDefinition.name
            ? Buffer.from(aggregatorDefinition.name)
            : Buffer.from("");
        const startAfter = (_g = aggregatorDefinition.startAfter) !== null && _g !== void 0 ? _g : 0;
        const varianceThreshold = (_h = aggregatorDefinition.varianceThreshold) !== null && _h !== void 0 ? _h : 0;
        const aggregatorAccount = await switchboard_v2_1.AggregatorAccount.create(this.program, {
            authorWallet,
            authority: authorityPubkey,
            batchSize,
            expiration,
            forceReportPeriod,
            metadata,
            minRequiredJobResults,
            minRequiredOracleResults: minRequiredOracleResults > batchSize
                ? batchSize
                : minRequiredOracleResults,
            minUpdateDelaySeconds,
            name,
            queueAccount,
            startAfter,
            varianceThreshold,
        });
        const aggregator = await aggregatorAccount.loadData();
        const jobs = [];
        if (aggregatorDefinition.jobs) {
            for await (const job of aggregatorDefinition.jobs) {
                const jobDefinition = JSON.parse(JSON.stringify(job), utils_1.pubKeyConverter);
                const data = Buffer.from(switchboard_v2_1.OracleJob.encodeDelimited(switchboard_v2_1.OracleJob.create({
                    tasks: jobDefinition.tasks,
                })).finish());
                const account = await switchboard_v2_1.JobAccount.create(this.program, {
                    data,
                    name: jobDefinition.name
                        ? Buffer.from(jobDefinition.name)
                        : Buffer.from(""),
                    expiration: jobDefinition.expiration
                        ? new anchor.BN(jobDefinition.expiration)
                        : new anchor.BN(0),
                    authority: (_j = jobDefinition.authorityWalletPublicKey) !== null && _j !== void 0 ? _j : payerKeypair.publicKey,
                });
                jobs.push(account);
            }
        }
        for await (const job of jobs) {
            await aggregatorAccount.addJob(job, authority);
        }
        if (!this.silent) {
            this.logger.log(await (0, sbv2_utils_1.prettyPrintAggregator)(aggregatorAccount, aggregator, false, false, true));
        }
        if (this.silent) {
            console.log(aggregator.publicKey.toString());
        }
        else {
            this.logger.info(`${chalk_1.default.green(`${utils_1.CHECK_ICON}Aggregator created successfully from JSON file\r\n`)}`);
        }
    }
    async catch(error) {
        super.catch(error, "failed to create aggregator from json file");
    }
}
exports.default = JsonCreateAggregator;
JsonCreateAggregator.description = "create an aggregator from a json file";
JsonCreateAggregator.aliases = ["json:create:aggregator"];
JsonCreateAggregator.flags = {
    ...BaseCommand_1.default.flags,
    queueKey: core_1.Flags.string({
        description: "public key of the oracle queue to create aggregator for",
        char: "q",
    }),
    authority: core_1.Flags.string({
        description: "alternate keypair that will be the authority for the aggregator",
        char: "a",
    }),
};
JsonCreateAggregator.args = [
    {
        name: "definitionFile",
        description: "filesystem path of queue definition json file",
    },
];
JsonCreateAggregator.examples = [
    "$ sbv2 aggregator:create:json examples/aggregator.json --keypair ../payer-keypair.json --queueKey GhYg3R1V6DmJbwuc57qZeoYG6gUuvCotUF1zU3WCj98U --outputFile aggregator.schema.json",
];
