"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const core_1 = require("@oclif/core");
const anchor = tslib_1.__importStar(require("@project-serum/anchor"));
const spl = tslib_1.__importStar(require("@solana/spl-token-v2"));
const web3_js_1 = require("@solana/web3.js");
const sbv2_utils_1 = require("@switchboard-xyz/sbv2-utils");
const switchboard_v2_1 = require("@switchboard-xyz/switchboard-v2");
const big_js_1 = tslib_1.__importDefault(require("big.js"));
const fs_1 = tslib_1.__importDefault(require("fs"));
const path_1 = tslib_1.__importDefault(require("path"));
const BaseCommand_1 = tslib_1.__importDefault(require("../../../BaseCommand"));
const utils_1 = require("../../../utils");
// TODO: Finish
class AggregatorCreate extends BaseCommand_1.default {
    async run() {
        var _a, _b, _c, _d, _e, _f;
        (0, utils_1.verifyProgramHasPayer)(this.program);
        const { args, flags } = await this.parse(AggregatorCreate);
        const payerKeypair = (0, switchboard_v2_1.programWallet)(this.program);
        const feedAuthority = await this.loadAuthority(flags.authority);
        const queueAuthority = await this.loadAuthority(flags.queueAuthority);
        const [programStateAccount, stateBump] = switchboard_v2_1.ProgramStateAccount.fromSeed(this.program);
        const queueAccount = new switchboard_v2_1.OracleQueueAccount({
            program: this.program,
            publicKey: new web3_js_1.PublicKey(args.queueKey),
        });
        const queue = await queueAccount.loadData();
        const mint = await queueAccount.loadMint();
        const tokenWallet = await spl.getOrCreateAssociatedTokenAccount(this.program.provider.connection, payerKeypair, mint.address, payerKeypair.publicKey, undefined, undefined, undefined, spl.TOKEN_PROGRAM_ID, spl.ASSOCIATED_TOKEN_PROGRAM_ID);
        const createAccountInstructions = [];
        const createAccountSigners = [
            payerKeypair,
            feedAuthority,
            queueAuthority,
        ];
        // Create Job Accounts
        const createJobs = flags.job
            ? await Promise.all(flags.job.map(async (jobDefinition) => {
                const jobJson = JSON.parse(fs_1.default.readFileSync(jobDefinition.startsWith("/")
                    ? jobDefinition
                    : path_1.default.join(process.cwd(), jobDefinition), "utf8"));
                if (!jobJson || !("tasks" in jobJson)) {
                    throw new Error("job definition missing tasks");
                }
                const jobKeypair = anchor.web3.Keypair.generate();
                const data = Buffer.from(switchboard_v2_1.OracleJob.encodeDelimited(switchboard_v2_1.OracleJob.create({
                    tasks: jobJson.tasks,
                })).finish());
                const size = 280 + data.length;
                const allocateAccountIxn = web3_js_1.SystemProgram.createAccount({
                    fromPubkey: payerKeypair.publicKey,
                    newAccountPubkey: jobKeypair.publicKey,
                    space: size,
                    lamports: await this.program.provider.connection.getMinimumBalanceForRentExemption(size),
                    programId: this.program.programId,
                });
                const createJobIxn = await this.program.methods
                    .jobInit({
                    name: Buffer.from("").slice(0, 32),
                    data: data,
                    variables: new Array(),
                    authorWallet: payerKeypair.publicKey,
                    stateBump,
                })
                    .accounts({
                    job: jobKeypair.publicKey,
                    authorWallet: tokenWallet.address,
                    authority: feedAuthority.publicKey,
                    programState: programStateAccount.publicKey,
                })
                    .signers([feedAuthority])
                    .instruction();
                return [[allocateAccountIxn, createJobIxn], jobKeypair];
            }))
            : [];
        const createJobIxn = createJobs.map((index) => index[0]);
        const createJobSigners = createJobs.map((index) => index[1]);
        const jobAccounts = createJobs
            .map((index) => index[1])
            .map((jobKeypair) => {
            return new switchboard_v2_1.JobAccount({
                program: this.program,
                publicKey: jobKeypair.publicKey,
                keypair: jobKeypair,
            });
        });
        // Create Aggregator Account
        const aggregatorKeypair = anchor.web3.Keypair.generate();
        const aggregatorSize = this.program.account.aggregatorAccountData.size;
        const aggregatorAccount = new switchboard_v2_1.AggregatorAccount({
            program: this.program,
            publicKey: aggregatorKeypair.publicKey,
        });
        const [permissionAccount, permissionBump] = switchboard_v2_1.PermissionAccount.fromSeed(this.program, queue.authority, queueAccount.publicKey, aggregatorKeypair.publicKey);
        createAccountInstructions.push([
            web3_js_1.SystemProgram.createAccount({
                fromPubkey: payerKeypair.publicKey,
                newAccountPubkey: aggregatorKeypair.publicKey,
                space: aggregatorSize,
                lamports: await this.program.provider.connection.getMinimumBalanceForRentExemption(aggregatorSize),
                programId: this.program.programId,
            }),
            // create aggregator
            await this.program.methods
                .aggregatorInit({
                name: Buffer.from((_a = flags.name) !== null && _a !== void 0 ? _a : "").slice(0, 32),
                metadata: Buffer.from("").slice(0, 64),
                batchSize: (_b = flags.batchSize) !== null && _b !== void 0 ? _b : 1,
                minOracleResults: (_c = flags.minOracles) !== null && _c !== void 0 ? _c : 1,
                minJobResults: (_d = flags.minJobs) !== null && _d !== void 0 ? _d : 1,
                minUpdateDelaySeconds: (_e = flags.updateInterval) !== null && _e !== void 0 ? _e : 30,
                varianceThreshold: flags.varianceThreshold
                    ? switchboard_v2_1.SwitchboardDecimal.fromBig(new big_js_1.default(flags.varianceThreshold))
                    : switchboard_v2_1.SwitchboardDecimal.fromBig(new big_js_1.default(0)),
                forceReportPeriod: new anchor.BN((_f = flags.forceReportPeriod) !== null && _f !== void 0 ? _f : 0),
                stateBump,
            })
                .accounts({
                aggregator: aggregatorKeypair.publicKey,
                authority: feedAuthority.publicKey,
                queue: queueAccount.publicKey,
                authorWallet: tokenWallet.address,
                programState: programStateAccount.publicKey,
            })
                .instruction(),
            await this.program.methods
                .permissionInit({})
                .accounts({
                permission: permissionAccount.publicKey,
                authority: queue.authority,
                granter: queueAccount.publicKey,
                grantee: aggregatorKeypair.publicKey,
                payer: payerKeypair.publicKey,
                systemProgram: web3_js_1.SystemProgram.programId,
            })
                .instruction(),
            flags.enable && queueAuthority.publicKey.equals(queue.authority)
                ? await this.program.methods
                    .permissionSet({
                    permission: { permitOracleQueueUsage: undefined },
                    enable: true,
                })
                    .accounts({
                    permission: permissionAccount.publicKey,
                    authority: queueAuthority.publicKey,
                })
                    .instruction()
                : undefined,
        ].filter((item) => item));
        createAccountSigners.push(aggregatorKeypair);
        // Create Lease Account
        // Add to crank if applicable
        const [leaseAccount, leaseBump] = switchboard_v2_1.LeaseAccount.fromSeed(this.program, queueAccount, aggregatorAccount);
        const leaseEscrow = await spl.getAssociatedTokenAddress(mint.address, leaseAccount.publicKey, true, spl.TOKEN_PROGRAM_ID, spl.ASSOCIATED_TOKEN_PROGRAM_ID);
        createAccountInstructions.push([
            spl.createAssociatedTokenAccountInstruction(payerKeypair.publicKey, leaseEscrow, leaseAccount.publicKey, mint.address, spl.TOKEN_PROGRAM_ID, spl.ASSOCIATED_TOKEN_PROGRAM_ID),
            await this.program.methods
                .leaseInit({
                loadAmount: new anchor.BN(0),
                stateBump,
                leaseBump,
                withdrawAuthority: feedAuthority.publicKey,
                walletBumps: Buffer.from([]),
            })
                .accounts({
                programState: programStateAccount.publicKey,
                lease: leaseAccount.publicKey,
                queue: queueAccount.publicKey,
                aggregator: aggregatorAccount.publicKey,
                systemProgram: web3_js_1.SystemProgram.programId,
                funder: tokenWallet.address,
                payer: payerKeypair.publicKey,
                tokenProgram: spl.TOKEN_PROGRAM_ID,
                escrow: leaseEscrow,
                owner: payerKeypair.publicKey,
                mint: mint.address,
            })
                // .remainingAccounts(
                //   jobPubkeys.concat(jobWallets).map((pubkey: PublicKey) => {
                //     return { isSigner: false, isWritable: true, pubkey };
                //   })
                // )
                .instruction(),
            flags.crankKey
                ? await this.program.methods
                    .crankPush({
                    stateBump,
                    permissionBump,
                    nofitiRef: null,
                    notifiRef: null,
                })
                    .accounts({
                    crank: new web3_js_1.PublicKey(flags.crankKey),
                    aggregator: aggregatorKeypair.publicKey,
                    oracleQueue: queueAccount.publicKey,
                    queueAuthority: queue.authority,
                    permission: permissionAccount.publicKey,
                    lease: leaseAccount.publicKey,
                    escrow: leaseEscrow,
                    programState: programStateAccount.publicKey,
                    dataBuffer: (await new switchboard_v2_1.CrankAccount({
                        program: this.program,
                        publicKey: new web3_js_1.PublicKey(flags.crankKey),
                    }).loadData()).dataBuffer,
                })
                    .instruction()
                : undefined,
        ].filter((item) => item));
        // Add Job Accounts
        const addJobIxns = await Promise.all(jobAccounts.map(async (job) => {
            return this.program.methods
                .aggregatorAddJob({
                weight: 1,
            })
                .accounts({
                aggregator: aggregatorKeypair.publicKey,
                authority: feedAuthority.publicKey,
                job: job.publicKey,
            })
                .instruction();
        }));
        const createAccountSignatures = (0, sbv2_utils_1.packAndSend)(this.program, [createJobIxn, createAccountInstructions, addJobIxns], [...createJobSigners, ...createAccountSigners], payerKeypair.publicKey).catch((error) => {
            throw error;
        });
        let aggInitWs;
        const aggInitPromise = new Promise((resolve) => {
            aggInitWs = this.program.provider.connection.onAccountChange(aggregatorKeypair.publicKey, (accountInfo, slot) => {
                const aggData = new anchor.BorshAccountsCoder(this.program.idl).decode("AggregatorAccountData", accountInfo.data);
                resolve(aggData);
            });
        });
        const result = await (0, sbv2_utils_1.promiseWithTimeout)(45000, aggInitPromise).finally(() => {
            try {
                this.program.provider.connection.removeAccountChangeListener(aggInitWs);
            }
            catch { }
        });
        if (this.silent) {
            console.log(aggregatorAccount.publicKey.toString());
        }
        await (0, sbv2_utils_1.sleep)(2500);
        this.logger.info(await (0, sbv2_utils_1.prettyPrintAggregator)(aggregatorAccount, result, true, true, true));
    }
    async catch(error) {
        super.catch(error, "Failed to create aggregator account");
    }
}
exports.default = AggregatorCreate;
AggregatorCreate.description = "create an aggregator account";
AggregatorCreate.flags = {
    ...BaseCommand_1.default.flags,
    authority: core_1.Flags.string({
        char: "a",
        description: "alternate keypair that is the authority for the aggregator",
    }),
    crankKey: core_1.Flags.string({
        description: "public key of the crank to join",
    }),
    enable: core_1.Flags.boolean({
        description: "set permissions to PERMIT_ORACLE_QUEUE_USAGE",
    }),
    queueAuthority: core_1.Flags.string({
        description: "alternative keypair to use for queue authority",
    }),
    name: core_1.Flags.string({
        char: "n",
        description: "name of the aggregator",
    }),
    forceReportPeriod: core_1.Flags.integer({
        description: "Number of seconds for which, even if the variance threshold is not passed, accept new responses from oracles.",
    }),
    batchSize: core_1.Flags.integer({
        description: "number of oracles requested for each open round call",
    }),
    minJobs: core_1.Flags.integer({
        description: "number of jobs that must respond before an oracle responds",
    }),
    minOracles: core_1.Flags.integer({
        description: "number of oracles that must respond before a value is accepted on-chain",
    }),
    updateInterval: core_1.Flags.integer({
        description: "set an aggregator's minimum update delay",
    }),
    varianceThreshold: core_1.Flags.string({
        description: "percentage change between a previous accepted result and the next round before an oracle reports a value on-chain. Used to conserve lease cost during low volatility",
    }),
    job: core_1.Flags.string({
        char: "j",
        description: "filesystem path to job definition file",
        multiple: true,
    }),
};
AggregatorCreate.args = [
    {
        name: "queueKey",
        description: "public key of the oracle queue account to create aggregator for",
    },
];
