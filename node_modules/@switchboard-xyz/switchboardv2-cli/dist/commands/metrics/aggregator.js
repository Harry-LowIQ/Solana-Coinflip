"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
/* eslint-disable unicorn/prevent-abbreviations */
/* eslint-disable complexity */
const core_1 = require("@oclif/core");
const anchor = tslib_1.__importStar(require("@project-serum/anchor"));
const web3_js_1 = require("@solana/web3.js");
const sbv2_utils_1 = require("@switchboard-xyz/sbv2-utils");
const switchboard_v2_1 = require("@switchboard-xyz/switchboard-v2");
const bs58_1 = tslib_1.__importDefault(require("bs58"));
const fs_1 = tslib_1.__importDefault(require("fs"));
const path_1 = tslib_1.__importDefault(require("path"));
const BaseCommand_1 = tslib_1.__importDefault(require("../../BaseCommand"));
class MetricsAggregator extends BaseCommand_1.default {
    async run() {
        const { args, flags } = await this.parse(MetricsAggregator);
        const parsedPath = path_1.default.parse(args.outputFile.startsWith("/") || args.outputFile.startsWith("C:")
            ? args.outputFile
            : path_1.default.join(process.cwd(), args.outputFile));
        this.outputBasePath = path_1.default.join(parsedPath.dir, parsedPath.name);
        if (parsedPath.ext === ".txt" || flags.txt) {
            this.outputTxtFile = `${this.outputBasePath}.txt`;
            if (fs_1.default.existsSync(this.outputTxtFile) && !flags.force) {
                throw new Error(`output txt file already exists: ${this.outputTxtFile}`);
            }
        }
        if (parsedPath.ext === ".json" || flags.json) {
            this.outputJsonFile = `${this.outputBasePath}.json`;
            if (fs_1.default.existsSync(this.outputJsonFile) && !flags.force) {
                throw new Error(`output json file already exists: ${this.outputJsonFile}`);
            }
        }
        if (parsedPath.ext === ".csv" || flags.csv) {
            this.outputCsvFile = `${this.outputBasePath}.csv`;
            if (fs_1.default.existsSync(this.outputCsvFile) && !flags.force) {
                throw new Error(`output csv file already exists: ${this.outputCsvFile}`);
            }
        }
        if (!(this.outputJsonFile || this.outputCsvFile || this.outputTxtFile)) {
            throw new Error(`no output format specified, try --txt, --json, or --csv`);
        }
        const accountCoder = new anchor.BorshAccountsCoder(this.program.idl);
        const aggregatorDiscriminator = Uint8Array.from([
            217, 230, 65, 101, 201, 162, 27, 125,
        ]);
        this.aggregatorAccounts =
            await this.program.provider.connection.getProgramAccounts(this.program.programId, {
                filters: [
                    {
                        memcmp: {
                            offset: 0,
                            bytes: bs58_1.default.encode(aggregatorDiscriminator),
                        },
                    },
                ],
            });
        const aggregatorPubkeys = this.aggregatorAccounts.map((account) => account.pubkey.toString());
        const allAggregators = await buildAggregators(this.logger, this.program, this.aggregatorAccounts);
        if (flags.jobDirectory) {
            const jobDirPath = flags.jobDirectory.startsWith("/") ||
                flags.jobDirectory.startsWith("C:")
                ? flags.jobDirectory
                : path_1.default.join(process.cwd(), flags.jobDirectory);
            fs_1.default.mkdirSync(jobDirPath, { recursive: true });
            for (const aggregator of allAggregators) {
                for (const job of aggregator.jobs) {
                    if (!job) {
                        this.logger.debug(`Job is undefined`);
                        continue;
                    }
                    if (!("tasks" in job)) {
                        this.logger.debug(`Job has no tasks - ${job.publicKey}`);
                        continue;
                    }
                    const firstTask = Object.keys(job.tasks[0])[0];
                    const oracleJob = switchboard_v2_1.OracleJob.create({ tasks: job.tasks });
                    const jobObject = {};
                    // const jobObject = oracleJob.toJSON();
                    if (job.name) {
                        jobObject.name = job.name;
                    }
                    if (job.metadata) {
                        jobObject.metadata = job.metadata;
                    }
                    // if (job.authority) {
                    //   jobObject["authority"] = job.authority;
                    // }
                    try {
                        const taskPath = path_1.default.join(jobDirPath, firstTask);
                        fs_1.default.mkdirSync(taskPath, { recursive: true });
                        fs_1.default.writeFileSync(path_1.default.join(taskPath, `${job.publicKey.toString()}.json`), JSON.stringify({
                            ...jobObject,
                            ...oracleJob.toJSON(),
                        }, undefined, 2));
                    }
                    catch {
                        this.logger.debug(`Error - ${firstTask}`);
                    }
                }
            }
        }
        const aggregators = [];
        // output list of aggregators by a given task type
        if (flags.task) {
            // const aggregators: Aggregator[] = [];
            for (const aggregator of allAggregators) {
                // check aggregator job definitions for task type
                for (const job of aggregator.jobs) {
                    if (job === undefined || job.tasks === undefined) {
                        continue;
                    }
                    const jobString = JSON.stringify(job.tasks).toLowerCase();
                    if (jobString.includes(flags.task.toLowerCase())) {
                        aggregators.push(aggregator);
                        break;
                    }
                }
            }
        }
        else if (flags.queue) {
            for (const aggregator of allAggregators) {
                if (aggregator.queuePubkey.toString() === flags.queue) {
                    aggregators.push(aggregator);
                }
            }
        }
        else {
            aggregators.push(...allAggregators);
        }
        writeAggregators(aggregators, this.outputTxtFile, this.outputJsonFile, this.outputCsvFile);
    }
    async catch(error) {
        super.catch(error, "failed to filter aggregator jobs");
    }
}
exports.default = MetricsAggregator;
MetricsAggregator.description = "get metrics on switchboard aggregators";
MetricsAggregator.hidden = true;
MetricsAggregator.flags = {
    ...BaseCommand_1.default.flags,
    force: core_1.Flags.boolean({
        description: "overwrite outputFile if it already exists",
    }),
    task: core_1.Flags.string({
        description: "search for a given string in an aggregator task definitions",
        required: false,
    }),
    queue: core_1.Flags.string({
        description: "oracle queue to filter aggregators by",
        required: false,
    }),
    json: core_1.Flags.boolean({
        description: "output aggregator accounts in json format",
    }),
    csv: core_1.Flags.boolean({
        description: "output aggregator accounts in csv format",
    }),
    txt: core_1.Flags.boolean({
        description: "output aggregator pubkeys in txt format",
    }),
    jobDirectory: core_1.Flags.string({
        description: "output the aggregator jobs to a directory sorted by the first task type",
    }),
};
MetricsAggregator.args = [
    {
        name: "outputFile",
        required: true,
        description: "Output file to save accounts to. An extension of txt, csv, or json will affect output format.",
    },
];
function writeAggregators(aggregators, outputTxtFile, outputJsonFile, outputCsvFile) {
    // write txt file
    if (outputTxtFile) {
        fs_1.default.writeFileSync(outputTxtFile, aggregators.map((a) => a.publicKey.toString()).join("\n"));
    }
    // write json file
    if (outputJsonFile) {
        fs_1.default.writeFileSync(outputJsonFile, JSON.stringify(aggregators, undefined, 2));
    }
    // write csv file or output to console
    if (outputCsvFile) {
        const headers = [
            "name",
            "metadata",
            "publicKey",
            "authority",
            "queuePubkey",
            "crankPubkey",
            "historyBuffer",
            "oracleRequestBatchSize",
            "minOracleResults",
            "minJobResults",
            "minUpdateDelaySeconds",
            "varianceThreshold",
            "forceReportPeriod",
        ];
        const rows = aggregators.map((a) => {
            return [
                a.name,
                a.metadata,
                a.publicKey.toString(),
                a.authority.toString(),
                a.queuePubkey.toString(),
                a.crankPubkey.toString(),
                a.historyBuffer.toString(),
                a.oracleRequestBatchSize.toString(),
                a.minOracleResults.toString(),
                a.minJobResults.toString(),
                a.minUpdateDelaySeconds.toString(),
                a.varianceThreshold.toString(),
                a.forceReportPeriod.toString(),
            ];
        });
        if (outputCsvFile) {
            fs_1.default.writeFileSync(outputCsvFile, `${headers.join(",")}\n${rows.map((r) => r.join(",")).join("\n")}`);
        }
        // if (!flags.silent) {
        //   console.table(table.rows, table.headers);
        // }
    }
}
async function buildAggregators(logger, program, aggregatorAccounts) {
    const accountCoder = new anchor.BorshAccountsCoder(program.idl);
    // get all job pubkeys tied to aggregators
    const jobPubkeys = aggregatorAccounts.flatMap((agg) => {
        const aggregatorData = accountCoder.decode("AggregatorAccountData", agg.account.data);
        const jobKeys = aggregatorData.jobPubkeysData.slice(0, aggregatorData.jobPubkeysSize).filter((pubkey) => pubkey !== anchor.web3.PublicKey.default);
        return jobKeys;
    });
    // store a map of job pubkeys and their definitions
    const jobMap = await buildJobMap(logger, program, jobPubkeys);
    const aggregators = [];
    for await (const account of aggregatorAccounts) {
        const aggregatorData = accountCoder.decode("AggregatorAccountData", account.account.data);
        const jobKeys = aggregatorData.jobPubkeysData.slice(0, aggregatorData.jobPubkeysSize).filter((pubkey) => pubkey !== anchor.web3.PublicKey.default);
        const jobs = jobKeys.map((jobKey) => jobMap.get(jobKey.toString()));
        const aggregator = new Aggregator(account.pubkey, aggregatorData, jobs);
        aggregators.push(aggregator);
    }
    return aggregators;
}
async function buildJobMap(logger, program, pubkeys, max = 300) {
    function sliceIntoChunks(array, chunkSize) {
        const res = [];
        for (let index = 0; index < array.length; index += chunkSize) {
            const chunk = array.slice(index, index + chunkSize);
            res.push(chunk);
        }
        return res;
    }
    const jobMap = new Map();
    const publicKeys = sliceIntoChunks(pubkeys, max);
    for await (const pubKeyBatch of publicKeys) {
        const jobAccountInfos = await program.account.jobAccountData.fetchMultiple(pubKeyBatch);
        for (const [index, jobAccountData] of jobAccountInfos.entries()) {
            try {
                const publicKey = pubKeyBatch[index];
                const oracleJob = switchboard_v2_1.OracleJob.decodeDelimited(jobAccountData.data);
                const job = new Job(publicKey, jobAccountData, oracleJob.tasks);
                //   console.log(`jobKey: ${publicKey}, ${JSON.stringify(job)}`);
                jobMap.set(publicKey.toString(), job);
            }
            catch (error) {
                logger.debug(`JobDecodeError: ${pubKeyBatch[index]} - ${error}`);
            }
        }
    }
    return jobMap;
}
class Job {
    constructor(publicKey, jobData, tasks) {
        this.publicKey = publicKey;
        this.tasks = tasks;
        this.name = (0, sbv2_utils_1.buffer2string)(jobData.name);
        this.metadata = (0, sbv2_utils_1.buffer2string)(jobData.metadata);
        this.authority =
            jobData.authority && !web3_js_1.PublicKey.default.equals(jobData.authority)
                ? jobData.authority
                : undefined;
        this.expiration = jobData.expiration.toNumber();
        this.hash = jobData.hash;
        this.referenceCount = jobData.referenceCount;
        this.totalSpent = jobData.totalSpent;
    }
    toJSON() {
        var _a, _b;
        return {
            publicKey: this.publicKey.toString(),
            name: this.name,
            metadata: this.metadata,
            authority: this.authority ? "N/A" : (_b = (_a = this.authority) === null || _a === void 0 ? void 0 : _a.toString()) !== null && _b !== void 0 ? _b : "",
            expiration: this.expiration,
            hash: this.hash.toString(),
            referenceCount: this.referenceCount,
            totalSpent: this.totalSpent,
            tasks: this.tasks,
        };
    }
}
class Aggregator {
    constructor(publicKey, aggregatorData, jobs) {
        this.publicKey = publicKey;
        this.jobs = jobs;
        this.name = (0, sbv2_utils_1.buffer2string)(aggregatorData.name);
        this.metadata = (0, sbv2_utils_1.buffer2string)(aggregatorData.metadata);
        this.authorWallet =
            aggregatorData.authorWallet &&
                !web3_js_1.PublicKey.default.equals(aggregatorData.authorWallet)
                ? aggregatorData.authorWallet
                : web3_js_1.PublicKey.default;
        this.queuePubkey =
            aggregatorData.queuePubkey &&
                !web3_js_1.PublicKey.default.equals(aggregatorData.queuePubkey)
                ? aggregatorData.queuePubkey
                : web3_js_1.PublicKey.default;
        this.oracleRequestBatchSize = aggregatorData.oracleRequestBatchSize;
        this.minOracleResults = aggregatorData.minOracleResults;
        this.minJobResults = aggregatorData.minJobResults;
        this.minUpdateDelaySeconds = aggregatorData.minUpdateDelaySeconds;
        this.startAfter = aggregatorData.startAfter;
        this.varianceThreshold = switchboard_v2_1.SwitchboardDecimal.from(aggregatorData.varianceThreshold).toBig();
        this.forceReportPeriod = aggregatorData.forceReportPeriod;
        this.expiration = aggregatorData.expiration.toNumber();
        this.crankPubkey =
            aggregatorData.crankPubkey &&
                !web3_js_1.PublicKey.default.equals(aggregatorData.crankPubkey)
                ? aggregatorData.crankPubkey
                : web3_js_1.PublicKey.default;
        this.jobPubkeysSize = aggregatorData.jobPubkeysSize;
        this.authority = aggregatorData.authority;
        this.historyBuffer =
            aggregatorData.historyBuffer &&
                !web3_js_1.PublicKey.default.equals(aggregatorData.historyBuffer)
                ? aggregatorData.historyBuffer
                : web3_js_1.PublicKey.default;
        this.disableCrank = aggregatorData.disableCrank;
    }
    toJSON() {
        return {
            publicKey: this.publicKey.toString(),
            name: this.name,
            metadata: this.metadata,
            authorWallet: this.authorWallet.equals(web3_js_1.PublicKey.default)
                ? "N/A"
                : this.authorWallet.toString(),
            queuePubkey: this.queuePubkey.equals(web3_js_1.PublicKey.default)
                ? "N/A"
                : this.queuePubkey.toString(),
            oracleRequestBatchSize: this.oracleRequestBatchSize,
            minOracleResults: this.minOracleResults,
            minJobResults: this.minJobResults,
            minUpdateDelaySeconds: this.minUpdateDelaySeconds,
            startAfter: this.startAfter.toNumber(),
            varianceThreshold: this.varianceThreshold.toNumber(),
            forceReportPeriod: this.forceReportPeriod.toNumber(),
            expiration: this.expiration,
            crankPubkey: this.crankPubkey.equals(web3_js_1.PublicKey.default)
                ? "N/A"
                : this.crankPubkey.toString(),
            jobPubkeysSize: this.jobPubkeysSize,
            authority: this.authority.equals(web3_js_1.PublicKey.default)
                ? "N/A"
                : this.authority.toString(),
            historyBuffer: this.historyBuffer.equals(web3_js_1.PublicKey.default)
                ? "N/A"
                : this.historyBuffer.toString(),
            disableCrank: this.disableCrank,
            jobs: this.jobs.map((job) => (job === undefined ? "N/A" : job.toJSON())),
        };
    }
}
