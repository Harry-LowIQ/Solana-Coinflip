"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const anchor = tslib_1.__importStar(require("@project-serum/anchor"));
const spl = tslib_1.__importStar(require("@solana/spl-token-v2"));
const web3_js_1 = require("@solana/web3.js");
const sbv2_utils_1 = require("@switchboard-xyz/sbv2-utils");
const switchboard_v2_1 = require("@switchboard-xyz/switchboard-v2");
const BaseCommand_1 = tslib_1.__importDefault(require("../BaseCommand"));
const utils_1 = require("../utils");
function fromBN(n, decimals = 0) {
    const big = new switchboard_v2_1.SwitchboardDecimal(n, decimals).toBig();
    // assert(n.cmp(new anchor.BN(big.toFixed())) === 0);
    return big;
}
class TestCommand extends BaseCommand_1.default {
    async run() {
        const { args, flags } = await this.parse(TestCommand);
        (0, sbv2_utils_1.verifyProgramHasPayer)(this.program);
        const oracleAuthority = (0, switchboard_v2_1.programWallet)(this.program);
        const oracleAccount = new switchboard_v2_1.OracleAccount({
            program: this.program,
            publicKey: new web3_js_1.PublicKey(args.oracleKey),
        });
        /// //////////////////////////////////////////////////
        const oracle = await oracleAccount.loadData();
        const queueAccount = new switchboard_v2_1.OracleQueueAccount({
            program: oracleAccount.program,
            publicKey: oracle.queuePubkey,
        });
        const queue = await queueAccount.loadData();
        const mint = await queueAccount.loadMint();
        const [programState, stateBump] = switchboard_v2_1.ProgramStateAccount.fromSeed(oracleAccount.program);
        const [permissionAccount, permissionBump] = switchboard_v2_1.PermissionAccount.fromSeed(oracleAccount.program, queue.authority, queueAccount.publicKey, oracleAccount.publicKey);
        const balanceNeeded = await spl.getMinimumBalanceForRentExemptAccount(oracleAccount.program.provider.connection);
        const minimumStakingWalletAmount = queue.minStake.isZero()
            ? // 0.1 wSOL
                new anchor.BN(0.1 * web3_js_1.LAMPORTS_PER_SOL)
            : // 1.10x queue's minStake
                queue.minStake.add(queue.minStake.div(new anchor.BN(10)));
        // Check and create nonce account here
        const nonceSeed = "UnwrapStakingWallet";
        const noncePubkey = anchor.utils.publicKey.createWithSeedSync(oracleAuthority.publicKey, nonceSeed, web3_js_1.SystemProgram.programId);
        try {
            const nonceAccount = await oracleAccount.program.provider.connection.getNonce(noncePubkey);
            if (!nonceAccount) {
                throw new Error("NonceAccount has not been created");
            }
        }
        catch (error) {
            if (error.message !== "NonceAccount has not been created") {
                throw error;
            }
            const nonceRentExemption = await oracleAccount.program.provider.connection.getMinimumBalanceForRentExemption(web3_js_1.NONCE_ACCOUNT_LENGTH);
            const nonceTxn = new web3_js_1.Transaction({ feePayer: oracleAuthority.publicKey });
            nonceTxn.add(web3_js_1.SystemProgram.createAccountWithSeed({
                fromPubkey: oracleAuthority.publicKey,
                newAccountPubkey: noncePubkey,
                basePubkey: oracleAuthority.publicKey,
                seed: nonceSeed,
                lamports: nonceRentExemption,
                space: web3_js_1.NONCE_ACCOUNT_LENGTH,
                programId: web3_js_1.SystemProgram.programId,
            }), // init nonce account
            web3_js_1.SystemProgram.nonceInitialize({
                noncePubkey: noncePubkey,
                authorizedPubkey: oracleAuthority.publicKey,
            }));
            const nonceSignature = await oracleAccount.program.provider.sendAndConfirm(nonceTxn, [
                oracleAuthority,
            ]);
            this.logger.info(`Created oracle nonce account to automatically unwrap oracle staking wallet, ${noncePubkey}, ${nonceSignature}`);
        }
        oracleAccount.program.provider.connection.onAccountChange(oracleAuthority.publicKey, async (accountInfo, slot) => {
            const nodeBalance = accountInfo.lamports / web3_js_1.LAMPORTS_PER_SOL;
            if (nodeBalance < 0.5) {
                const stakingWalletAmount = (await oracleAccount.program.provider.connection.getTokenAccountBalance(oracle.tokenAccount)).value;
                const unwrapAmountBN = new anchor.BN(stakingWalletAmount.amount).sub(minimumStakingWalletAmount);
                if (unwrapAmountBN.isNeg()) {
                    this.logger.warn(`Oracle Authority is low on funds and not enough funds in the staking wallet to cover`);
                }
                const unwrapAmountUi = fromBN(unwrapAmountBN).div(web3_js_1.LAMPORTS_PER_SOL);
                this.logger.info(`NodeBalance: ${nodeBalance}, unwrapping ${unwrapAmountUi} SOL`);
                // Load nonce
                const nonceAccount = await oracleAccount.program.provider.connection.getNonce(noncePubkey);
                if (!nonceAccount) {
                    throw new Error("Failed to create and load nonceAccount");
                }
                // Create transaction
                const newAccount = anchor.web3.Keypair.generate();
                const txn = new web3_js_1.Transaction({
                    feePayer: oracleAuthority.publicKey,
                    recentBlockhash: undefined,
                    nonceInfo: {
                        nonce: nonceAccount.nonce,
                        nonceInstruction: web3_js_1.SystemProgram.nonceAdvance({
                            noncePubkey: noncePubkey,
                            authorizedPubkey: oracleAuthority.publicKey,
                        }),
                    },
                });
                // create new wSOL account
                txn.add(web3_js_1.SystemProgram.createAccount({
                    fromPubkey: oracleAuthority.publicKey,
                    newAccountPubkey: newAccount.publicKey,
                    lamports: balanceNeeded,
                    space: spl.AccountLayout.span,
                    programId: spl.TOKEN_PROGRAM_ID,
                }), spl.createInitializeAccountInstruction(newAccount.publicKey, mint.address, oracleAuthority.publicKey, spl.TOKEN_PROGRAM_ID), await oracleAccount.program.methods
                    .oracleWithdraw({
                    permissionBump,
                    stateBump,
                    amount: new anchor.BN(1), // only 1 token
                })
                    .accounts({
                    oracle: oracleAccount.publicKey,
                    oracleAuthority: oracleAuthority.publicKey,
                    tokenAccount: oracle.tokenAccount,
                    withdrawAccount: newAccount.publicKey,
                    oracleQueue: queueAccount.publicKey,
                    permission: permissionAccount.publicKey,
                    tokenProgram: spl.TOKEN_PROGRAM_ID,
                    programState: programState.publicKey,
                    systemProgram: web3_js_1.SystemProgram.programId,
                    payer: oracleAuthority.publicKey,
                })
                    .instruction(), spl.createCloseAccountInstruction(newAccount.publicKey, oracleAuthority.publicKey, oracleAuthority.publicKey, [newAccount], spl.TOKEN_PROGRAM_ID));
                const signature = await oracleAccount.program.provider.sendAndConfirm(txn, [oracleAuthority, newAccount]);
                this.logger.info(`Successfully unwrapped ${1} wSOL from oracles staking wallet: ${signature}`);
            }
        });
        this.logger.info("Finished command");
        await (0, utils_1.sleep)(5 * 60 * 1000);
    }
    async catch(error) {
        super.catch(error, "test command failed");
    }
}
exports.default = TestCommand;
TestCommand.description = "sandbox";
TestCommand.flags = {
    ...BaseCommand_1.default.flags,
    // name: Flags.string({
    //   char: "n",
    //   description: "name of the job account for easier identification",
    //   default: "",
    // }),
};
TestCommand.args = [
    {
        name: "oracleKey",
        description: "public key of the oracle to deposit funds into",
    },
];
