"use strict";
/* eslint-disable unicorn/prevent-abbreviations */
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const core_1 = require("@oclif/core");
const web3_js_1 = require("@solana/web3.js");
const sbv2_utils_1 = require("@switchboard-xyz/sbv2-utils");
const child_process_1 = require("child_process");
const fs_1 = tslib_1.__importDefault(require("fs"));
const path_1 = tslib_1.__importDefault(require("path"));
const BaseCommand_1 = tslib_1.__importDefault(require("../../BaseCommand"));
class AnchorTest extends BaseCommand_1.default {
    constructor() {
        super(...arguments);
        this.timestamp = Date.now();
    }
    saveLogs(logs, nodeImage) {
        if (!fs_1.default.existsSync(".switchboard")) {
            fs_1.default.mkdirSync(".switchboard");
        }
        const fileName = path_1.default.join(".switchboard", `docker.${nodeImage}.${Math.floor(this.timestamp / 1000)}.log`);
        const filteredLogs = logs.filter((l) => Boolean);
        if (filteredLogs.length > 0) {
            fs_1.default.writeFileSync(fileName, filteredLogs.join(""));
            return fileName;
        }
        return null;
    }
    startDockerOracle(nodeImage, platform, oracleKey, keypairPath, silent = false, allLogs = []) {
        this.dockerOracleProcess = (0, child_process_1.spawn)("docker", ["start", "--attach", `sbv2-localnet-${nodeImage}`], {
            shell: true,
            env: process.env,
            stdio: silent ? null : ["inherit", "pipe", "pipe"],
        });
        this.dockerOracleProcess.stdout.on("data", (data) => {
            allLogs.push(data.toString());
            // logs.push(`\x1b[34m${data.toString()}\x1b[0m`);
            if (!silent) {
                console.log(`\x1b[34m${data.toString()}\x1b[0m`);
            }
        });
        this.dockerOracleProcess.stderr.on("error", (error) => {
            allLogs.push(error.toString());
            // logs.push(`\x1b[31m${error.toString()}\x1b[0m`);
            if (!silent) {
                console.error(`\x1b[31m${error.toString()}\x1b[0m`);
            }
        });
        this.dockerOracleProcess.on("close", (code) => {
            this.saveLogs(allLogs, nodeImage);
            if (code === 0) {
                this.startDockerOracle(nodeImage, platform, oracleKey, keypairPath, silent, allLogs);
            }
            else if (!silent) {
                console.error(`\x1b[31mDocker image exited with code ${code}\x1b[0m`);
            }
            else if (code !== 0 && code !== 1) {
                console.error(`\x1b[31mDocker image exited with code ${code}\x1b[0m`);
            }
        });
    }
    createDockerOracle(nodeImage, platform, oracleKey, keypairPath, silent = false, allLogs = []) {
        this.dockerOracleProcess = (0, child_process_1.spawn)("docker", [
            "run",
            `--name sbv2-localnet-${nodeImage}`,
            `--platform=${platform}`,
            `-e ORACLE_KEY=${oracleKey}`,
            `-e CLUSTER=localnet`,
            `-e VERBOSE=1`,
            `--mount type=bind,source=${keypairPath},target=/home/payer_secrets.json`,
            `switchboardlabs/node:${nodeImage}`,
        ], {
            shell: true,
            env: process.env,
            stdio: silent ? null : ["inherit", "pipe", "pipe"],
        });
        // let logs: string[] = [];
        this.dockerOracleProcess.stdout.on("data", (data) => {
            // logs.push(`\x1b[34m${data}\x1b[0m`);
            console.log(`\x1b[34m${data}\x1b[0m`);
            allLogs.push(data);
        });
        this.dockerOracleProcess.stderr.on("error", (error) => {
            if (!silent ||
                !error
                    .toString()
                    .includes(`The container name "/sbv2-localnet-${nodeImage}" is already in use by container`)) {
                // logs.push(`\x1b[31m${error.toString()}\x1b[0m`);
                console.error(`\x1b[31m${error.toString()}\x1b[0m`);
                allLogs.push(error.toString());
            }
        });
        this.dockerOracleProcess.on("close", (code) => {
            this.saveLogs(allLogs, nodeImage);
            // if reboot from no RPC or if image already exists
            if (code === 0 || code === 125) {
                this.startDockerOracle(nodeImage, platform, oracleKey, keypairPath, silent, allLogs);
            }
            else if (!silent) {
                console.error(`\x1b[31mDocker image exited with code ${code}\x1b[0m`);
            }
            else if (code !== 0) {
                console.error(`\x1b[31mDocker image exited with code ${code}\x1b[0m`);
            }
        });
    }
    async run() {
        (0, sbv2_utils_1.verifyProgramHasPayer)(this.program);
        const { flags } = await this.parse(AnchorTest);
        let oraclePubkey;
        if (flags.oracleKey) {
            oraclePubkey = new web3_js_1.PublicKey(flags.oracleKey);
        }
        else {
            const switchboard = await sbv2_utils_1.SwitchboardTestContext.loadFromEnv(this.program.provider, flags.switchboardDir || undefined);
            oraclePubkey = switchboard.oracle.publicKey;
        }
        let isFinished = false;
        const keypairPath = flags.keypair.charAt(0) === "/" || flags.keypair.startsWith("C:")
            ? flags.keypair
            : path_1.default.join(process.cwd(), flags.keypair);
        const oracleKey = oraclePubkey;
        // start docker oracle first
        this.createDockerOracle(flags.nodeImage, flags.arm ? "linux/arm64" : "linux/amd64", oracleKey, keypairPath, flags.silent);
        this.anchorChildProcess = (0, child_process_1.spawn)("anchor", ["test"], {
            shell: true,
            cwd: process.cwd(),
            env: process.env,
            stdio: "inherit",
        });
        this.anchorChildProcess.on("message", (data) => {
            if (data.toString().includes("âœ¨  Done")) {
                (0, child_process_1.exec)(`docker kill sbv2-localnet-${flags.nodeImage}`);
                this.dockerOracleProcess.kill();
                isFinished = true;
            }
        });
        this.anchorChildProcess.on("close", (code) => {
            // console.log(`anchor test process closing ...`);
            (0, child_process_1.exec)(`docker stop sbv2-localnet-${flags.nodeImage}`);
            isFinished = true;
        });
        const refreshInterval = Math.ceil(flags.timeout / 20);
        let retryCount = 20;
        while (retryCount > 0) {
            if (isFinished) {
                break;
            }
            await (0, sbv2_utils_1.sleep)(refreshInterval * 1000);
            --retryCount;
        }
        try {
            this.anchorChildProcess.kill();
            this.dockerOracleProcess.kill();
        }
        catch { }
    }
    async catch(error) {
        super.catch(error, "Failed to create localnet test environment");
    }
}
exports.default = AnchorTest;
AnchorTest.description = "run anchor test and a switchboard oracle in parallel";
AnchorTest.flags = {
    ...BaseCommand_1.default.flags,
    switchboardDir: core_1.Flags.string({
        char: "d",
        description: "directory with switchboard.env to load a switchboard environment",
    }),
    oracleKey: core_1.Flags.string({
        description: "public key of the oracle to start-up",
    }),
    nodeImage: core_1.Flags.string({
        description: "public key of the oracle to start-up",
        default: "dev-v2-08-14-22a-mc-beta",
    }),
    arm: core_1.Flags.boolean({
        description: "apple silicon needs to use a docker image for linux/arm64",
    }),
    timeout: core_1.Flags.integer({
        char: "t",
        default: 120,
        description: "number of seconds before timing out",
    }),
    silent: core_1.Flags.boolean({
        char: "s",
        description: "suppress docker logging",
    }),
};
