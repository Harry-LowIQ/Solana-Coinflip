"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const core_1 = require("@oclif/core");
const web3_js_1 = require("@solana/web3.js");
const sbv2_utils_1 = require("@switchboard-xyz/sbv2-utils");
const switchboard_v2_1 = require("@switchboard-xyz/switchboard-v2");
const fs_1 = tslib_1.__importDefault(require("fs"));
const path_1 = tslib_1.__importDefault(require("path"));
const BaseCommand_1 = tslib_1.__importDefault(require("../../BaseCommand"));
const utils_1 = require("../../utils");
class BufferCreate extends BaseCommand_1.default {
    async run() {
        (0, utils_1.verifyProgramHasPayer)(this.program);
        const { args, flags } = await this.parse(BufferCreate);
        const payerKeypair = (0, switchboard_v2_1.programWallet)(this.program);
        const authority = await this.loadAuthority(flags.authority);
        let jobAccount;
        if (flags.jobDefinition) {
            const jobDefinitionPath = flags.jobDefinition.startsWith("/")
                ? flags.jobDefinition
                : path_1.default.join(process.cwd(), flags.jobDefinition);
            if (!fs_1.default.existsSync(jobDefinitionPath)) {
                throw new Error(`jobDefinitionPath does not exist, ${jobDefinitionPath}`);
            }
            const oracleJob = switchboard_v2_1.OracleJob.create(JSON.parse(fs_1.default.readFileSync(jobDefinitionPath, "utf-8")));
            jobAccount = await switchboard_v2_1.JobAccount.create(this.program, {
                authority: authority.publicKey,
                name: flags.name ? Buffer.from(flags.name) : Buffer.from(""),
                data: Buffer.from(switchboard_v2_1.OracleJob.encodeDelimited(oracleJob).finish()),
            });
        }
        else if (flags.jobKey) {
            jobAccount = new switchboard_v2_1.JobAccount({
                program: this.program,
                publicKey: new web3_js_1.PublicKey(flags.jobKey),
            });
        }
        else {
            throw new Error(`Need to provide --jobDefinition or --jobKey flag`);
        }
        const queueAccount = new switchboard_v2_1.OracleQueueAccount({
            program: this.program,
            publicKey: new web3_js_1.PublicKey(args.queueKey),
        });
        const bufferRelayerAccount = await switchboard_v2_1.BufferRelayerAccount.create(this.program, {
            authority: authority.publicKey,
            name: flags.name ? Buffer.from(flags.name) : Buffer.from(""),
            minUpdateDelaySeconds: flags.minUpdateDelaySeconds,
            queueAccount,
            jobAccount,
        });
        if (this.silent) {
            this.logger.info(bufferRelayerAccount.publicKey.toString());
            return;
        }
        this.logger.info(await (0, sbv2_utils_1.prettyPrintBufferRelayer)(bufferRelayerAccount));
    }
    async catch(error) {
        super.catch(error, "failed to create buffer relayer account");
    }
}
exports.default = BufferCreate;
BufferCreate.description = "create a buffer relayer account";
BufferCreate.flags = {
    ...BaseCommand_1.default.flags,
    authority: core_1.Flags.string({
        char: "a",
        description: "alternate keypair that will be the aggregator authority",
    }),
    name: core_1.Flags.string({
        char: "n",
        description: "name of the buffer account",
    }),
    minUpdateDelaySeconds: core_1.Flags.integer({
        description: "minimum number of seconds between update calls",
        default: 30,
    }),
    jobDefinition: core_1.Flags.string({
        description: "filesystem path to job definition",
        exclusive: ["jobKey"],
    }),
    jobKey: core_1.Flags.string({
        description: "public key of existing job account",
        exclusive: ["jobDefinition"],
    }),
};
BufferCreate.args = [
    {
        name: "queueKey",
        description: "oracle queue to create BufferRelayer account on",
    },
];
