"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const core_1 = require("@oclif/core");
const anchor = tslib_1.__importStar(require("@project-serum/anchor"));
const web3_js_1 = require("@solana/web3.js");
const sbv2_utils_1 = require("@switchboard-xyz/sbv2-utils");
const switchboard_v2_1 = require("@switchboard-xyz/switchboard-v2");
const big_js_1 = tslib_1.__importDefault(require("big.js"));
const chalk_1 = tslib_1.__importDefault(require("chalk"));
const fs = tslib_1.__importStar(require("fs"));
const path = tslib_1.__importStar(require("path"));
const config_1 = require("./config");
const types_1 = require("./types");
const FsProvider_1 = require("./types/context/FsProvider");
const logging_1 = require("./types/context/logging");
const utils_1 = require("./utils");
class BaseCommand extends core_1.Command {
    async init() {
        var _a, _b, _c, _d;
        const { flags } = await this.parse(this.constructor);
        BaseCommand.flags = flags;
        // setup logging
        this.silent = flags.silent;
        this.verbose = flags.verbose;
        const level = flags.silent
            ? "error"
            : flags.verbose
                ? "debug"
                : "info";
        const logFilename = path.join(this.config.cacheDir, "log.txt");
        const logParameters = {
            console: {
                level,
            },
            file: {
                level: "debug",
                filename: logFilename,
            },
            silent: (_a = this.silent) !== null && _a !== void 0 ? _a : false,
            verbose: (_b = this.verbose) !== null && _b !== void 0 ? _b : false,
        };
        this.logger = new logging_1.LogProvider(logParameters);
        fs.mkdirSync(this.config.dataDir, { recursive: true });
        this.loadConfig();
        this.cluster = flags.mainnetBeta
            ? (0, utils_1.toCluster)("mainnet-beta")
            : (0, utils_1.toCluster)("devnet");
        const url = (_d = (_c = flags.rpcUrl) !== null && _c !== void 0 ? _c : this.getRpcUrl(this.cluster)) !== null && _d !== void 0 ? _d : (0, web3_js_1.clusterApiUrl)(this.cluster);
        try {
            this.connection = new web3_js_1.Connection(url, {
                commitment: "confirmed",
            });
        }
        catch {
            this.connection = new web3_js_1.Connection((0, web3_js_1.clusterApiUrl)(this.cluster), {
                commitment: "confirmed",
            });
            this.logger.log(`resetting rpc url for ${this.cluster}. invalid URL ${url}`);
            this.setConfig(this.cluster === "devnet" ? "devnet-rpc" : "mainnet-rpc", (0, web3_js_1.clusterApiUrl)(this.cluster));
        }
        this.payerKeypair = flags.keypair
            ? await (0, utils_1.loadKeypair)(flags.keypair)
            : web3_js_1.Keypair.fromSeed(new Uint8Array(32).fill(1));
        const programId = flags.programId
            ? new anchor.web3.PublicKey(flags.programId)
            : (0, switchboard_v2_1.getSwitchboardPid)(this.cluster);
        const wallet = new switchboard_v2_1.AnchorWallet(this.payerKeypair);
        const provider = new anchor.AnchorProvider(this.connection, wallet, {
            commitment: "confirmed",
            // preflightCommitment: "finalized",
        });
        const anchorIdl = await anchor.Program.fetchIdl(programId, provider);
        if (!anchorIdl) {
            throw new Error(`failed to read idl for ${programId}`);
        }
        this.program = new anchor.Program(anchorIdl, programId, provider);
        if (this.verbose) {
            this.logger.log("verbose logging enabled");
        }
        this.logger.debug(chalk_1.default.underline(chalk_1.default.blue("## Config".padEnd(16))));
        this.logger.debug(`${chalk_1.default.yellow("cluster:")} ${chalk_1.default.blue(this.cluster)}`);
        this.logger.debug(`${chalk_1.default.yellow("rpc:")} ${chalk_1.default.blue(url)}`);
        this.context = {
            logger: this.logger,
            fs: new FsProvider_1.FsProvider(this.config.dataDir, this.logger),
            config: this.cliConfig,
        };
    }
    async catch(error, message) {
        var _a;
        // fall back to console if logger is not initialized yet
        const logger = (_a = this.logger) !== null && _a !== void 0 ? _a : console;
        if (message) {
            logger.info(chalk_1.default.red(`${utils_1.FAILED_ICON}${message}`));
        }
        if (error.message) {
            const messageLines = error.message.split("\n");
            logger.error(messageLines[0]);
        }
        if (this.verbose) {
            console.error(error);
        }
        // if (error.stack) {
        //   logger.error(error);
        // } else {
        //   logger.error(error.toString());
        // }
        // this.exit(1); // causes unreadable errors?
    }
    /** Load an authority from a CLI flag and optionally check if it matches the expected account authority */
    async loadAuthority(authorityPath, expectedAuthority) {
        const authority = typeof authorityPath === "string"
            ? await (0, utils_1.loadKeypair)(authorityPath)
            : (0, switchboard_v2_1.programWallet)(this.program);
        if (expectedAuthority && !expectedAuthority.equals(authority.publicKey)) {
            throw new types_1.AuthorityMismatch();
        }
        return authority;
    }
    mainnetCheck() {
        if (this.cluster === "mainnet-beta") {
            throw new Error("switchboardv2-cli is still in beta, mainnet is disabled for this command.");
        }
    }
    loadConfig() {
        const configPath = path.join(this.config.configDir, "config.json");
        if (fs.existsSync(configPath)) {
            const userConfig = JSON.parse(fs.readFileSync(configPath, "utf-8"));
            this.cliConfig = userConfig;
        }
        else {
            fs.mkdirSync(this.config.configDir, { recursive: true });
            this.saveConfig(config_1.DEFAULT_CONFIG);
        }
    }
    saveConfig(config) {
        this.cliConfig = config;
        const configPath = path.join(this.config.configDir, "config.json");
        fs.writeFileSync(configPath, JSON.stringify(config, undefined, 2));
        this.logger.info(chalk_1.default.green("Saved Config: ") + configPath);
    }
    setConfig(parameter, value) {
        switch (parameter) {
            case "devnet-rpc": {
                const newConfig = {
                    ...this.cliConfig,
                    devnet: {
                        ...this.cliConfig.devnet,
                        rpcUrl: value || (0, web3_js_1.clusterApiUrl)((0, utils_1.toCluster)("devnet")),
                    },
                };
                this.saveConfig(newConfig);
                break;
            }
            case "mainnet-rpc": {
                const newConfig = {
                    ...this.cliConfig,
                    mainnet: {
                        ...this.cliConfig.devnet,
                        rpcUrl: value || (0, web3_js_1.clusterApiUrl)((0, utils_1.toCluster)("mainnet-beta")),
                    },
                };
                this.saveConfig(newConfig);
                break;
            }
            default: {
                this.logger.warn("not implemented yet");
            }
        }
    }
    getRpcUrl(cluster) {
        var _a, _b;
        switch (cluster) {
            case "devnet":
                return ((_a = this.cliConfig.devnet.rpcUrl) !== null && _a !== void 0 ? _a : (0, web3_js_1.clusterApiUrl)((0, utils_1.toCluster)("devnet")));
            case "mainnet-beta":
                return ((_b = this.cliConfig.mainnet.rpcUrl) !== null && _b !== void 0 ? _b : (0, web3_js_1.clusterApiUrl)((0, utils_1.toCluster)("mainnet-beta")));
            default:
                return (0, web3_js_1.clusterApiUrl)((0, utils_1.toCluster)("devnet"));
        }
    }
    // Converts a string to a tokenAmount
    // If a decimal is found, it will be normalized using 9 decimal places
    getTokenAmount(value, decimals = 9) {
        if (Number.isNaN(Number(value))) {
            throw new TypeError("tokenAmount must be an integer or decimal");
        }
        if (value.split(".").length > 1) {
            const float = new big_js_1.default(value);
            const scale = sbv2_utils_1.BigUtils.safePow(new big_js_1.default(10), decimals);
            const tokenAmount = sbv2_utils_1.BigUtils.safeMul(float, scale);
            return new anchor.BN(tokenAmount.toFixed(0));
        }
        return new anchor.BN(value);
    }
}
BaseCommand.flags = {
    verbose: core_1.Flags.boolean({
        char: "v",
        description: "log everything",
    }),
    silent: core_1.Flags.boolean({
        char: "s",
        description: "suppress cli prompts",
    }),
    mainnetBeta: core_1.Flags.boolean({
        description: "WARNING: use mainnet-beta solana cluster",
    }),
    rpcUrl: core_1.Flags.string({
        char: "u",
        description: "alternate RPC url",
    }),
    programId: core_1.Flags.string({
        description: "alternative Switchboard program ID to interact with",
    }),
    keypair: core_1.Flags.string({
        char: "k",
        description: "keypair that will pay for onchain transactions. defaults to new account authority if no alternate authority provided",
    }),
};
exports.default = BaseCommand;
