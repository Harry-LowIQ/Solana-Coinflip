"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isProgramStateAccount = exports.isLeaseAccount = exports.isPermissionAccount = exports.isOracleQueueAccount = exports.isCrankAccount = exports.isOracleAccount = exports.isAggregatorAccount = exports.isJobAccount = exports.anchorBNtoDateTimeString = exports.toDateTimeString = exports.anchorBNtoDateString = exports.toDateString = exports.buffer2string = exports.chalkString = exports.pubKeyReviver = exports.pubKeyConverter = exports.toPermission = exports.toVrfStatus = exports.toVrfStatus1 = exports.VrfStatus = exports.toPermissionString = exports.getArrayOfSizeN = void 0;
const tslib_1 = require("tslib");
const anchor = tslib_1.__importStar(require("@project-serum/anchor"));
const web3_js_1 = require("@solana/web3.js");
const switchboard_v2_1 = require("@switchboard-xyz/switchboard-v2");
const big_js_1 = tslib_1.__importDefault(require("big.js"));
const chalk_1 = tslib_1.__importDefault(require("chalk"));
const keypair_1 = require("./keypair");
const getArrayOfSizeN = (number_) => {
    return Array.from({ length: number_ }, (_, index) => index + 1);
};
exports.getArrayOfSizeN = getArrayOfSizeN;
// list of keys that will not be included in a json output file
const IGNORE_JSON_OUTPUT_KEYS = new Set([
    "account",
    "isActive",
    "logger",
]);
const toPermissionString = (permission) => {
    switch (permission) {
        case switchboard_v2_1.SwitchboardPermissionValue.PERMIT_ORACLE_HEARTBEAT:
            return "PERMIT_ORACLE_HEARTBEAT";
        case switchboard_v2_1.SwitchboardPermissionValue.PERMIT_ORACLE_QUEUE_USAGE:
            return "PERMIT_ORACLE_QUEUE_USAGE";
        default:
            return "NONE";
    }
};
exports.toPermissionString = toPermissionString;
var VrfStatus;
(function (VrfStatus) {
    VrfStatus["STATUS_NONE"] = "statusNone";
    VrfStatus["STATUS_REQUESTING"] = "statusRequesting";
    VrfStatus["STATUS_VERIFYING"] = "statusVerifying";
    VrfStatus["STATUS_VERIFIED"] = "statusVerifying";
    VrfStatus["STATUS_CALLBACK_SUCCESS"] = "statusCallbackSuccess";
    VrfStatus["STATUS_VERIFY_FAILURE"] = "statusVerifyFailure";
})(VrfStatus = exports.VrfStatus || (exports.VrfStatus = {}));
const toVrfStatus1 = (status) => {
    if ("statusNone" in status) {
        return "StatusNone";
    }
    if ("statusRequesting" in status) {
        return "StatusRequesting";
    }
    if ("statusVerifying" in status) {
        return "StatusVerifying";
    }
    if ("statusVerified" in status) {
        return "StatusVerified";
    }
    if ("statusCallbackSuccess" in status) {
        return "StatusCallbackSuccess";
    }
    if ("statusVerifyFailure" in status) {
        return "StatusVerifyFailure";
    }
    return "Unknown";
};
exports.toVrfStatus1 = toVrfStatus1;
const toVrfStatus = (status) => {
    if ("statusNone" in status) {
        return VrfStatus.STATUS_NONE;
    }
    if ("statusRequesting" in status) {
        return VrfStatus.STATUS_REQUESTING;
    }
    if ("statusVerifying" in status) {
        return VrfStatus.STATUS_VERIFYING;
    }
    if ("statusVerified" in status) {
        return VrfStatus.STATUS_VERIFIED;
    }
    if ("statusCallbackSuccess" in status) {
        return VrfStatus.STATUS_CALLBACK_SUCCESS;
    }
    if ("statusVerifyFailure" in status) {
        return VrfStatus.STATUS_VERIFY_FAILURE;
    }
    return "NONE";
};
exports.toVrfStatus = toVrfStatus;
const toPermission = (permissionString) => {
    switch (permissionString) {
        case "PERMIT_ORACLE_HEARTBEAT":
            return switchboard_v2_1.SwitchboardPermission.PERMIT_ORACLE_HEARTBEAT;
        case "PERMIT_ORACLE_QUEUE_USAGE":
            return switchboard_v2_1.SwitchboardPermission.PERMIT_ORACLE_QUEUE_USAGE;
        default:
            return "NONE";
    }
};
exports.toPermission = toPermission;
// JSON.stringify: Object => String
const pubKeyConverter = (key, value) => {
    var _a;
    if (value instanceof web3_js_1.PublicKey || key.toLowerCase().endsWith("publickey")) {
        return (_a = value.toString()) !== null && _a !== void 0 ? _a : "";
    }
    if (value instanceof Uint8Array) {
        return `[${value.toString()}]`;
    }
    if (value instanceof anchor.BN) {
        return value.toString();
    }
    if (value instanceof big_js_1.default) {
        return value.toString();
    }
    if (value instanceof switchboard_v2_1.SwitchboardDecimal) {
        return new big_js_1.default(value.mantissa.toString())
            .div(new big_js_1.default(10).pow(value.scale))
            .toString();
    }
    if (IGNORE_JSON_OUTPUT_KEYS.has(key))
        return undefined;
    return value;
};
exports.pubKeyConverter = pubKeyConverter;
// JSON.parse: String => Object
const pubKeyReviver = (key, value) => {
    if (key.toLowerCase().endsWith("publickey")) {
        return new web3_js_1.PublicKey(value);
    }
    if (key.toLowerCase().endsWith("secretkey")) {
        return new Uint8Array(JSON.parse(value));
    }
    if (key.toLowerCase().endsWith("keypair")) {
        return (0, keypair_1.loadKeypair)(value);
    }
    if (key.toLowerCase().startsWith("variancethreshold")) {
        return new switchboard_v2_1.SwitchboardDecimal(new anchor.BN(value.mantissa), value.scale);
    }
    return value;
};
exports.pubKeyReviver = pubKeyReviver;
const chalkString = (label, value, padding = 16) => {
    return `${chalk_1.default.blue(label.padEnd(padding, " "))}${chalk_1.default.yellow(value ? value.toString() : "undefined")}`;
};
exports.chalkString = chalkString;
/* eslint-disable no-control-regex */
const buffer2string = (buf) => {
    return Buffer.from(buf)
        .toString("utf8")
        .replace(/\u0000/g, ""); // removes padding from onchain fixed sized buffers
};
exports.buffer2string = buffer2string;
const padTime = (number_) => {
    return number_.toString().padStart(2, "0");
};
function toDateString(d) {
    if (d)
        return `${d.getFullYear()}-${padTime(d.getMonth() + 1)}-${padTime(d.getDate())} L`;
    return "";
}
exports.toDateString = toDateString;
function anchorBNtoDateString(ts) {
    if (!ts.toNumber())
        return "N/A";
    return toDateString(new Date(ts.toNumber() * 1000));
}
exports.anchorBNtoDateString = anchorBNtoDateString;
function toDateTimeString(d) {
    if (d)
        return `${d.getFullYear()}-${padTime(d.getMonth() + 1)}-${padTime(d.getDate())} ${padTime(d.getHours())}:${padTime(d.getMinutes())}:${padTime(d.getSeconds())} L`;
    return "";
}
exports.toDateTimeString = toDateTimeString;
function anchorBNtoDateTimeString(ts) {
    if (!ts.toNumber())
        return "N/A";
    return toDateTimeString(new Date(ts.toNumber() * 1000));
}
exports.anchorBNtoDateTimeString = anchorBNtoDateTimeString;
const isJobAccount = async (program, publicKey) => {
    try {
        const account = new switchboard_v2_1.JobAccount({ program, publicKey });
        await account.loadData();
        return account;
    }
    catch {
        return undefined;
    }
};
exports.isJobAccount = isJobAccount;
const isAggregatorAccount = async (program, publicKey) => {
    try {
        const account = new switchboard_v2_1.AggregatorAccount({ program, publicKey });
        await account.loadData();
        return account;
    }
    catch {
        return undefined;
    }
};
exports.isAggregatorAccount = isAggregatorAccount;
const isOracleAccount = async (program, publicKey) => {
    try {
        const account = new switchboard_v2_1.OracleAccount({ program, publicKey });
        await account.loadData();
        return account;
    }
    catch {
        return undefined;
    }
};
exports.isOracleAccount = isOracleAccount;
const isCrankAccount = async (program, publicKey) => {
    try {
        const account = new switchboard_v2_1.CrankAccount({ program, publicKey });
        await account.loadData();
        return account;
    }
    catch {
        return undefined;
    }
};
exports.isCrankAccount = isCrankAccount;
const isOracleQueueAccount = async (program, publicKey) => {
    try {
        const account = new switchboard_v2_1.OracleQueueAccount({ program, publicKey });
        await account.loadData();
        return account;
    }
    catch {
        return undefined;
    }
};
exports.isOracleQueueAccount = isOracleQueueAccount;
const isPermissionAccount = async (program, publicKey) => {
    try {
        const account = new switchboard_v2_1.PermissionAccount({ program, publicKey });
        await account.loadData();
        return account;
    }
    catch {
        return undefined;
    }
};
exports.isPermissionAccount = isPermissionAccount;
const isLeaseAccount = async (program, publicKey) => {
    try {
        const account = new switchboard_v2_1.LeaseAccount({ program, publicKey });
        await account.loadData();
        return account;
    }
    catch {
        return undefined;
    }
};
exports.isLeaseAccount = isLeaseAccount;
const isProgramStateAccount = async (program, publicKey) => {
    try {
        const account = new switchboard_v2_1.ProgramStateAccount({ program, publicKey });
        await account.loadData();
        return account;
    }
    catch {
        return undefined;
    }
};
exports.isProgramStateAccount = isProgramStateAccount;
// // should also check if pubkey is a token account
// export const findAccountType = async (
//   program: anchor.Program,
//   publicKey: PublicKey
// ): Promise<SwitchboardAccountType> => {
//   const account = await program.provider.connection.getAccountInfo(publicKey);
//   if (!account) {
//     throw new Error(`Failed to find account ${publicKey}`);
//   }
//   const accountDiscriminator = account.data.slice(
//     0,
//     ACCOUNT_DISCRIMINATOR_SIZE
//   );
//   for (const [name, discriminator] of SWITCHBOARD_DISCRIMINATOR_MAP.entries()) {
//     if (Buffer.compare(accountDiscriminator, discriminator) === 0) {
//       return name;
//     }
//   }
//   throw new Error(`no switchboard account found for ${publicKey}`);
// };
