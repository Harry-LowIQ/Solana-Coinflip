"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.loadKeypairWithDescriptor = exports.loadKeypair = exports.loadGoogleSecretKeypair = exports.loadKeypairFs = void 0;
const tslib_1 = require("tslib");
const secret_manager_1 = require("@google-cloud/secret-manager");
const web3_js_1 = require("@solana/web3.js");
const fs = tslib_1.__importStar(require("fs"));
const path = tslib_1.__importStar(require("path"));
const types_1 = require("../types");
const loadKeypairFs = (keypairPath) => {
    const fullPath = keypairPath.charAt(0) === "/"
        ? keypairPath
        : path.join(process.cwd(), keypairPath);
    if (!fs.existsSync(fullPath)) {
        throw new types_1.InvalidKeypairFsPathProvided(fullPath);
    }
    try {
        // const walletKeypair = Keypair.fromSecretKey(
        //   Buffer.from(
        //     JSON.parse(
        //       fs.readFileSync(process.env.ANCHOR_WALLET, {
        //         encoding: "utf-8",
        //       })
        //     )
        //   )
        // );
        const walletKeypair = web3_js_1.Keypair.fromSecretKey(new Uint8Array(JSON.parse(fs.readFileSync(fullPath, {
            encoding: "utf-8",
        }))));
        return walletKeypair;
    }
    catch (error) {
        throw new Error(`failed to load keypair from ${fullPath}: ${error}`);
    }
};
exports.loadKeypairFs = loadKeypairFs;
const loadGoogleSecretKeypair = async (secretPath) => {
    const client = new secret_manager_1.SecretManagerServiceClient();
    const [accessResponse] = await client.accessSecretVersion({
        name: secretPath.includes("/versions/")
            ? secretPath
            : `${secretPath}/versions/latest`,
    });
    const secrets = accessResponse.payload.data;
    if (secrets === undefined) {
        throw new Error("Google secret not found.");
    }
    let secretKey;
    if (typeof secrets === "string") {
        secretKey = new Uint8Array(Buffer.from(secrets));
    }
    else if (secrets instanceof Buffer) {
        secretKey = new Uint8Array(JSON.parse(secrets.toString()));
    }
    if (secretKey) {
        return web3_js_1.Keypair.fromSecretKey(secretKey);
    }
    throw new Error(`failed to read gcp secret`);
};
exports.loadGoogleSecretKeypair = loadGoogleSecretKeypair;
const loadKeypair = async (keypairPath) => {
    if (typeof keypairPath === "string") {
        try {
            const keypair = (0, exports.loadKeypairFs)(keypairPath);
            return keypair;
        }
        catch { }
        try {
            const keypair = await (0, exports.loadGoogleSecretKeypair)(keypairPath);
            return keypair;
        }
        catch { }
    }
    else if ("localPath" in keypairPath) {
        return (0, exports.loadKeypairFs)(keypairPath.localPath);
    }
    else if ("secretPath" in keypairPath) {
        return (0, exports.loadGoogleSecretKeypair)(keypairPath.secretPath);
    }
    throw new types_1.InvalidKeypairProvided(keypairPath);
};
exports.loadKeypair = loadKeypair;
/** Loads a keypair with a descriptor to find and retrieve on-command */
const loadKeypairWithDescriptor = async (keypairPath) => {
    if (typeof keypairPath === "string") {
        try {
            const keypair = (0, exports.loadKeypairFs)(keypairPath);
            const descriptor = {
                publicKey: keypair.publicKey,
                localPath: keypairPath,
            };
            return [keypair, descriptor];
        }
        catch {
            try {
                const keypair = await (0, exports.loadGoogleSecretKeypair)(keypairPath);
                const descriptor = {
                    publicKey: keypair.publicKey,
                    secretPath: keypairPath,
                };
                return [keypair, descriptor];
            }
            catch { }
        }
    }
    else if ("localPath" in keypairPath) {
        const keypair = (0, exports.loadKeypairFs)(keypairPath.localPath);
        const descriptor = {
            publicKey: keypair.publicKey,
            localPath: keypairPath.localPath,
        };
        return [keypair, descriptor];
    }
    else if ("secretPath" in keypairPath) {
        const keypair = await (0, exports.loadGoogleSecretKeypair)(keypairPath.secretPath);
        const descriptor = {
            publicKey: keypair.publicKey,
            secretPath: keypairPath.secretPath,
        };
        return [keypair, descriptor];
    }
    throw new types_1.InvalidKeypairProvided(keypairPath);
};
exports.loadKeypairWithDescriptor = loadKeypairWithDescriptor;
