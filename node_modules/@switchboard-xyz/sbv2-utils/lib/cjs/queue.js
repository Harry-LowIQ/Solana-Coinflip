"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createQueue = void 0;
const anchor = __importStar(require("@project-serum/anchor"));
const spl = __importStar(require("@solana/spl-token-v2"));
const web3_js_1 = require("@solana/web3.js");
const switchboard_v2_1 = require("@switchboard-xyz/switchboard-v2");
const big_js_1 = __importDefault(require("big.js"));
const print_js_1 = require("./print.js");
const transaction_js_1 = require("./transaction.js");
async function createQueue(program, params, queueSize = 500, authorityKeypair = (0, switchboard_v2_1.programWallet)(program)) {
    var _a, _b, _c, _d, _e;
    const payerKeypair = (0, switchboard_v2_1.programWallet)(program);
    const [programStateAccount, stateBump] = switchboard_v2_1.ProgramStateAccount.fromSeed(program);
    const mint = await spl.getMint(program.provider.connection, spl.NATIVE_MINT, undefined, spl.TOKEN_PROGRAM_ID);
    const ixns = [];
    const signers = [payerKeypair, authorityKeypair];
    try {
        await programStateAccount.loadData();
    }
    catch {
        const vaultKeypair = anchor.web3.Keypair.generate();
        ixns.push([
            web3_js_1.SystemProgram.createAccount({
                fromPubkey: payerKeypair.publicKey,
                newAccountPubkey: vaultKeypair.publicKey,
                lamports: await program.provider.connection.getMinimumBalanceForRentExemption(spl.AccountLayout.span),
                space: spl.AccountLayout.span,
                programId: spl.TOKEN_PROGRAM_ID,
            }),
            spl.createInitializeAccountInstruction(vaultKeypair.publicKey, mint.address, payerKeypair.publicKey, spl.TOKEN_PROGRAM_ID),
            await program.methods
                .programInit({
                stateBump,
            })
                .accounts({
                state: programStateAccount.publicKey,
                authority: payerKeypair.publicKey,
                tokenMint: mint.address,
                vault: vaultKeypair.publicKey,
                payer: payerKeypair.publicKey,
                systemProgram: web3_js_1.SystemProgram.programId,
                tokenProgram: spl.TOKEN_PROGRAM_ID,
                daoMint: mint.address,
            })
                .instruction(),
        ]);
        signers.push(vaultKeypair);
    }
    const queueKeypair = anchor.web3.Keypair.generate();
    const queueBuffer = anchor.web3.Keypair.generate();
    const queueBufferSize = queueSize * 32 + 8;
    const queueAccount = new switchboard_v2_1.OracleQueueAccount({
        program: program,
        publicKey: queueKeypair.publicKey,
    });
    console.debug((0, print_js_1.chalkString)("OracleQueue", queueKeypair.publicKey));
    console.debug((0, print_js_1.chalkString)("OracleBuffer", queueBuffer.publicKey));
    const crankKeypair = anchor.web3.Keypair.generate();
    const crankBuffer = anchor.web3.Keypair.generate();
    const crankSize = params.crankSize ? params.crankSize * 40 + 8 : 0;
    console.debug((0, print_js_1.chalkString)("CrankAccount", crankKeypair.publicKey));
    console.debug((0, print_js_1.chalkString)("CrankBuffer", crankBuffer.publicKey));
    const crankAccount = new switchboard_v2_1.CrankAccount({
        program: program,
        publicKey: crankKeypair.publicKey,
    });
    ixns.push(anchor.web3.SystemProgram.createAccount({
        fromPubkey: payerKeypair.publicKey,
        newAccountPubkey: queueBuffer.publicKey,
        space: queueBufferSize,
        lamports: await program.provider.connection.getMinimumBalanceForRentExemption(queueBufferSize),
        programId: program.programId,
    }), await program.methods
        .oracleQueueInit({
        name: Buffer.from((_a = params.name) !== null && _a !== void 0 ? _a : "").slice(0, 32),
        metadata: Buffer.from("").slice(0, 64),
        reward: params.reward ? new anchor.BN(params.reward) : new anchor.BN(0),
        minStake: params.minStake
            ? new anchor.BN(params.minStake)
            : new anchor.BN(0),
        // feedProbationPeriod: 0,
        oracleTimeout: params.oracleTimeout,
        slashingEnabled: false,
        varianceToleranceMultiplier: switchboard_v2_1.SwitchboardDecimal.fromBig(new big_js_1.default(2)),
        authority: authorityKeypair.publicKey,
        // consecutiveFeedFailureLimit: new anchor.BN(1000),
        // consecutiveOracleFailureLimit: new anchor.BN(1000),
        minimumDelaySeconds: 5,
        queueSize: queueSize,
        unpermissionedFeeds: (_b = params.unpermissionedFeeds) !== null && _b !== void 0 ? _b : false,
        unpermissionedVrf: (_c = params.unpermissionedVrf) !== null && _c !== void 0 ? _c : false,
        enableBufferRelayers: (_d = params.enableBufferRelayers) !== null && _d !== void 0 ? _d : false,
    })
        .accounts({
        oracleQueue: queueKeypair.publicKey,
        authority: authorityKeypair.publicKey,
        buffer: queueBuffer.publicKey,
        systemProgram: web3_js_1.SystemProgram.programId,
        payer: payerKeypair.publicKey,
        mint: mint.address,
    })
        .instruction(), anchor.web3.SystemProgram.createAccount({
        fromPubkey: payerKeypair.publicKey,
        newAccountPubkey: crankBuffer.publicKey,
        space: crankSize,
        lamports: await program.provider.connection.getMinimumBalanceForRentExemption(crankSize),
        programId: program.programId,
    }), await program.methods
        .crankInit({
        name: Buffer.from("Crank").slice(0, 32),
        metadata: Buffer.from("").slice(0, 64),
        crankSize: params.crankSize,
    })
        .accounts({
        crank: crankKeypair.publicKey,
        queue: queueKeypair.publicKey,
        buffer: crankBuffer.publicKey,
        systemProgram: web3_js_1.SystemProgram.programId,
        payer: payerKeypair.publicKey,
    })
        .instruction());
    signers.push(queueKeypair, queueBuffer, crankKeypair, crankBuffer);
    const finalTransactions = [];
    const oracleAccounts = await Promise.all(Array.from(Array(params.numOracles).keys()).map(async (n) => {
        const name = `Oracle-${n + 1}`;
        const tokenWalletKeypair = anchor.web3.Keypair.generate();
        const [oracleAccount, oracleBump] = switchboard_v2_1.OracleAccount.fromSeed(program, queueAccount, tokenWalletKeypair.publicKey);
        console.debug((0, print_js_1.chalkString)(name, oracleAccount.publicKey));
        const [permissionAccount, permissionBump] = switchboard_v2_1.PermissionAccount.fromSeed(program, authorityKeypair.publicKey, queueAccount.publicKey, oracleAccount.publicKey);
        console.debug((0, print_js_1.chalkString)(`Permission-${n + 1}`, permissionAccount.publicKey));
        finalTransactions.push([
            web3_js_1.SystemProgram.createAccount({
                fromPubkey: payerKeypair.publicKey,
                newAccountPubkey: tokenWalletKeypair.publicKey,
                lamports: await program.provider.connection.getMinimumBalanceForRentExemption(spl.AccountLayout.span),
                space: spl.AccountLayout.span,
                programId: spl.TOKEN_PROGRAM_ID,
            }),
            spl.createInitializeAccountInstruction(tokenWalletKeypair.publicKey, mint.address, programStateAccount.publicKey, spl.TOKEN_PROGRAM_ID),
            await program.methods
                .oracleInit({
                name: Buffer.from(name).slice(0, 32),
                metadata: Buffer.from("").slice(0, 128),
                stateBump,
                oracleBump,
            })
                .accounts({
                oracle: oracleAccount.publicKey,
                oracleAuthority: authorityKeypair.publicKey,
                queue: queueKeypair.publicKey,
                wallet: tokenWalletKeypair.publicKey,
                programState: programStateAccount.publicKey,
                systemProgram: web3_js_1.SystemProgram.programId,
                payer: payerKeypair.publicKey,
            })
                .instruction(),
            await program.methods
                .permissionInit({})
                .accounts({
                permission: permissionAccount.publicKey,
                authority: authorityKeypair.publicKey,
                granter: queueAccount.publicKey,
                grantee: oracleAccount.publicKey,
                payer: payerKeypair.publicKey,
                systemProgram: web3_js_1.SystemProgram.programId,
            })
                .instruction(),
            await program.methods
                .permissionSet({
                permission: { permitOracleHeartbeat: null },
                enable: true,
            })
                .accounts({
                permission: permissionAccount.publicKey,
                authority: authorityKeypair.publicKey,
            })
                .instruction(),
        ]);
        signers.push(tokenWalletKeypair);
        return {
            oracleAccount,
            name,
            permissionAccount,
            tokenWalletKeypair,
        };
    }));
    const createAccountSignatures = await (0, transaction_js_1.packAndSend)(program, [ixns, finalTransactions], signers, payerKeypair.publicKey);
    // const result = await program.provider.connection.confirmTransaction(
    //   createAccountSignatures[-1]
    // );
    return {
        queueAccount,
        crankPubkey: crankAccount.publicKey,
        oracles: (_e = oracleAccounts.map((o) => o.oracleAccount.publicKey)) !== null && _e !== void 0 ? _e : [],
    };
}
exports.createQueue = createQueue;
//# sourceMappingURL=queue.js.map