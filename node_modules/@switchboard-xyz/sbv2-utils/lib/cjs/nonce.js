"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.decodeNonceAccount = exports.getOracleNonceAccounts = exports.getOracleNonceQueueAccounts = exports.getOracleStakeUnwrapNonceAccount = exports.getOracleHeartbeatNonceAccount = exports.nonceAccountExists = exports.getNoncePubkeyFromSeed = void 0;
const anchor = __importStar(require("@project-serum/anchor"));
const web3_js_1 = require("@solana/web3.js");
const assert_1 = __importDefault(require("assert"));
const crypto_1 = __importDefault(require("crypto"));
function getNoncePubkeyFromSeed(oracleAccount, authority, baseSeed) {
    const seed = `${baseSeed}-${oracleAccount.publicKey.toBase58()}`;
    const seedHashBuffer = crypto_1.default.createHash("sha256").update(seed).digest();
    (0, assert_1.default)(seedHashBuffer.byteLength === 32);
    const seedHashString = seedHashBuffer.toString("hex").slice(0, 32);
    const derivedPubkey = anchor.utils.publicKey.createWithSeedSync(authority, seedHashString, web3_js_1.SystemProgram.programId);
    return [derivedPubkey, seedHashString];
}
exports.getNoncePubkeyFromSeed = getNoncePubkeyFromSeed;
function nonceAccountExists(accountInfo) {
    if (accountInfo && accountInfo.data) {
        const nonceAccount = decodeNonceAccount(accountInfo);
        if (nonceAccount.nonce) {
            return true;
        }
    }
    return false;
}
exports.nonceAccountExists = nonceAccountExists;
async function getOracleHeartbeatNonceAccount(oracleAccount, authority) {
    const [heartbeatNoncePubkey, heartbeatNonceSeed] = getNoncePubkeyFromSeed(oracleAccount, authority, "OracleHeartbeat");
    const accountInfo = await oracleAccount.program.provider.connection.getAccountInfo(heartbeatNoncePubkey);
    if (nonceAccountExists(accountInfo !== null && accountInfo !== void 0 ? accountInfo : undefined)) {
        return heartbeatNoncePubkey;
    }
    return null;
}
exports.getOracleHeartbeatNonceAccount = getOracleHeartbeatNonceAccount;
async function getOracleStakeUnwrapNonceAccount(oracleAccount, authority) {
    const [heartbeatNoncePubkey, heartbeatNonceSeed] = getNoncePubkeyFromSeed(oracleAccount, authority, "UnwrapStakeAccount");
    const accountInfo = await oracleAccount.program.provider.connection.getAccountInfo(heartbeatNoncePubkey);
    if (nonceAccountExists(accountInfo !== null && accountInfo !== void 0 ? accountInfo : undefined)) {
        return heartbeatNoncePubkey;
    }
    return null;
}
exports.getOracleStakeUnwrapNonceAccount = getOracleStakeUnwrapNonceAccount;
async function getOracleNonceQueueAccounts(oracleAccount, authority, queueSize = 1000) {
    // const queueBaseSeeds: string[] = Array.from(Array(queueSize).keys()).map(
    //   (n) => `NonceQueue-${n.toString().padStart(5, "0")}`
    // );
    // const noncePubkeyWithSeeds: [PublicKey, string][] = queueBaseSeeds.map(
    //   (seed) => getNoncePubkeyFromSeed(oracleAccount, authority, seed)
    // );
    // const pubkeyChunks: [PublicKey, string][][] = sliceIntoChunks(
    //   noncePubkeyWithSeeds,
    //   100
    // );
    // const nonceAccountInfos: {
    //   accountInfo: AccountInfo<Buffer>;
    //   pubkey: PublicKey;
    //   baseSeed: string;
    // }[] = (
    //   await Promise.all(
    //     pubkeyChunks.map(async (chunk) => {
    //       const accountInfos =
    //         await oracleAccount.program.provider.connection.getMultipleAccountsInfo(
    //           chunk.map((i) => i[0])
    //         );
    //       return accountInfos.map((accountInfo, idx) => {
    //         return {
    //           accountInfo,
    //           pubkey: chunk[idx][0],
    //           baseSeed: chunk[idx][1],
    //         };
    //       });
    //     })
    //   )
    // ).flat();
    const queueBaseSeeds = Array.from(Array(queueSize).keys()).map((n) => `NonceQueue-${n.toString().padStart(5, "0")}`);
    // [derivedPubkey, fullSeed, baseSeed]
    const noncePubkeyWithSeeds = queueBaseSeeds.map((baseSeed) => {
        const [derivedPubkey, fullSeed] = getNoncePubkeyFromSeed(oracleAccount, authority, baseSeed);
        return {
            pubkey: derivedPubkey,
            fullSeed,
            baseSeed,
        };
    });
    const pubkeyChunks = sliceIntoChunks(noncePubkeyWithSeeds, 100);
    const nonceAccountInfos = (await Promise.all(pubkeyChunks.map(async (chunk, chunkIdx) => {
        const accountInfos = (await oracleAccount.program.provider.connection.getMultipleAccountsInfo(chunk.map((i) => i.pubkey).filter(Boolean))).filter(Boolean);
        return accountInfos.map((accountInfo, idx) => {
            return {
                ...chunk[idx],
                accountInfo,
            };
        });
    }))).flat();
    const nonceQueuePubkeys = nonceAccountInfos
        .map((nonce, i) => {
        var _a;
        if (nonceAccountExists((_a = nonce.accountInfo) !== null && _a !== void 0 ? _a : undefined)) {
            return nonce.pubkey;
        }
        return undefined;
    })
        .filter(Boolean);
    return nonceQueuePubkeys;
}
exports.getOracleNonceQueueAccounts = getOracleNonceQueueAccounts;
async function getOracleNonceAccounts(oracleAccount) {
    const oracle = await oracleAccount.loadData();
    const heartbeatNonce = await getOracleHeartbeatNonceAccount(oracleAccount, oracle.oracleAuthority);
    const unwrapStakeNonce = await getOracleStakeUnwrapNonceAccount(oracleAccount, oracle.oracleAuthority);
    const queueNonces = await getOracleNonceQueueAccounts(oracleAccount, oracle.oracleAuthority);
    return {
        heartbeatNonce: heartbeatNonce !== null && heartbeatNonce !== void 0 ? heartbeatNonce : undefined,
        unwrapStakeNonce: unwrapStakeNonce !== null && unwrapStakeNonce !== void 0 ? unwrapStakeNonce : undefined,
        queueNonces,
    };
}
exports.getOracleNonceAccounts = getOracleNonceAccounts;
// slice an array into chunks with a max size
function sliceIntoChunks(arr, chunkSize) {
    const res = [[]];
    for (let i = 0; i < arr.length; i += chunkSize) {
        const chunk = arr.slice(i, i + chunkSize);
        res.push(chunk);
    }
    return res;
}
function decodeNonceAccount(info) {
    if (info === null) {
        throw new Error("FAILED_TO_FIND_ACCOUNT");
    }
    if (!info.owner.equals(web3_js_1.SystemProgram.programId)) {
        throw new Error("INVALID_ACCOUNT_OWNER");
    }
    if (info.data.length != web3_js_1.NONCE_ACCOUNT_LENGTH) {
        throw new Error(`Invalid account size`);
    }
    const data = Buffer.from(info.data);
    return web3_js_1.NonceAccount.fromAccountData(data);
}
exports.decodeNonceAccount = decodeNonceAccount;
//# sourceMappingURL=nonce.js.map