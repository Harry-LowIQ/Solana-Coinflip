"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createAggregatorReq = exports.createAggregator = exports.awaitOpenRound = void 0;
const anchor = __importStar(require("@project-serum/anchor"));
const spl = __importStar(require("@solana/spl-token-v2"));
const switchboard_v2_1 = require("@switchboard-xyz/switchboard-v2");
const big_js_1 = __importDefault(require("big.js"));
const async_js_1 = require("./async.js");
async function awaitOpenRound(aggregatorAccount, queueAccount, payerTokenWallet, expectedValue = undefined, timeout = 30) {
    // call open round and wait for new value
    const accountsCoder = new anchor.BorshAccountsCoder(aggregatorAccount.program.idl);
    let accountWs;
    const awaitUpdatePromise = new Promise((resolve, reject) => {
        var _a;
        accountWs = aggregatorAccount.program.provider.connection.onAccountChange((_a = aggregatorAccount === null || aggregatorAccount === void 0 ? void 0 : aggregatorAccount.publicKey) !== null && _a !== void 0 ? _a : anchor.web3.PublicKey.default, async (accountInfo) => {
            const aggregator = accountsCoder.decode("AggregatorAccountData", accountInfo.data);
            const latestResult = await aggregatorAccount.getLatestValue(aggregator);
            if (!latestResult) {
                return;
            }
            if (!expectedValue) {
                resolve(latestResult);
            }
            else if (latestResult === null || latestResult === void 0 ? void 0 : latestResult.eq(expectedValue)) {
                resolve(latestResult);
            }
            else {
                reject(`Value mismatch, expected ${expectedValue}, received ${latestResult}`);
            }
        });
    });
    const updatedValuePromise = (0, async_js_1.promiseWithTimeout)(timeout * 1000, awaitUpdatePromise, new Error(`aggregator failed to update in ${timeout} seconds`)).finally(() => {
        if (accountWs) {
            aggregatorAccount.program.provider.connection.removeAccountChangeListener(accountWs);
        }
    });
    await aggregatorAccount.openRound({
        oracleQueueAccount: queueAccount,
        payoutWallet: payerTokenWallet,
    });
    const result = await updatedValuePromise;
    if (!result) {
        throw new Error(`failed to update aggregator`);
    }
    return result;
}
exports.awaitOpenRound = awaitOpenRound;
async function signAndConfirmTransactions(program, transactions) {
    const signedTxs = await program.provider.wallet.signAllTransactions(transactions);
    for (const transaction of signedTxs) {
        // console.log(`Blockhash: ${transaction.recentBlockhash}`);
        const sig = await program.provider.connection.sendRawTransaction(transaction.serialize(), { skipPreflight: false, maxRetries: 10 });
        await program.provider.connection.confirmTransaction(sig);
    }
}
async function createAggregator(program, queueAccount, params, jobs, fundLeaseAmount = new anchor.BN(0)) {
    const req = await createAggregatorReq(program, queueAccount, params, jobs, fundLeaseAmount);
    const { blockhash } = await program.provider.connection.getLatestBlockhash();
    const packedTxns = (0, switchboard_v2_1.packInstructions)(req.ixns, (0, switchboard_v2_1.programWallet)(program).publicKey, blockhash);
    const signedTxns = (0, switchboard_v2_1.signTransactions)(packedTxns, req.signers);
    await signAndConfirmTransactions(program, signedTxns);
    return req.account;
}
exports.createAggregator = createAggregator;
/**
 * Retrieve information about the payer's associated token account. If it does not exist, an
 * instruction to create it will be returned with the account's {@linkcode PublicKey}.
 */
async function getPayerTokenAccount(connection, payer, mint) {
    const publicKey = await spl.getAssociatedTokenAddress(mint, payer, undefined, spl.TOKEN_PROGRAM_ID, spl.ASSOCIATED_TOKEN_PROGRAM_ID);
    const accountExists = await connection
        .getAccountInfo(publicKey)
        .then((info) => info !== null)
        .catch(() => false);
    return {
        publicKey,
        ixn: accountExists
            ? undefined // Account exists, so theres no need to create it.
            : spl.createAssociatedTokenAccountInstruction(payer, publicKey, payer, mint, spl.TOKEN_PROGRAM_ID, spl.ASSOCIATED_TOKEN_PROGRAM_ID),
    };
}
async function createAggregatorReq(program, queueAccount, params, jobs, fundLeaseAmount = new anchor.BN(0), payerPubkey = (0, switchboard_v2_1.programWallet)(program).publicKey) {
    var _a, _b, _c, _d, _e, _f, _g;
    const queue = await queueAccount.loadData();
    const mint = await queueAccount.loadMint();
    // Aggregator params
    const aggregatorKeypair = (_a = params.keypair) !== null && _a !== void 0 ? _a : anchor.web3.Keypair.generate();
    const authority = (_b = params.authority) !== null && _b !== void 0 ? _b : payerPubkey;
    const size = program.account.aggregatorAccountData.size;
    const [programStateAccount, stateBump] = switchboard_v2_1.ProgramStateAccount.fromSeed(program);
    const state = await programStateAccount.loadData();
    const aggregatorAccount = new switchboard_v2_1.AggregatorAccount({
        program,
        publicKey: aggregatorKeypair.publicKey,
    });
    // Permission params
    const [permissionAccount, permissionBump] = switchboard_v2_1.PermissionAccount.fromSeed(program, queue.authority, queueAccount.publicKey, aggregatorKeypair.publicKey);
    // Lease params
    const [leaseAccount, leaseBump] = switchboard_v2_1.LeaseAccount.fromSeed(program, queueAccount, aggregatorAccount);
    const leaseEscrow = await spl.getAssociatedTokenAddress(mint.address, leaseAccount.publicKey, true, spl.TOKEN_PROGRAM_ID, spl.ASSOCIATED_TOKEN_PROGRAM_ID);
    // const jobPubkeys: Array<PublicKey> = [];
    // const jobWallets: Array<PublicKey> = [];
    // const walletBumps: Array<number> = [];
    // for (const idx in jobs) {
    //   const [jobWallet, bump] = anchor.utils.publicKey.findProgramAddressSync(
    //     [
    //       payerKeypair.publicKey.toBuffer(),
    //       spl.TOKEN_PROGRAM_ID.toBuffer(),
    //       mint.address.toBuffer(),
    //     ],
    //     spl.ASSOCIATED_TOKEN_PROGRAM_ID
    //   );
    //   jobPubkeys.push(jobs[idx].publicKey);
    //   jobWallets.push(jobWallet);
    //   walletBumps.push(bump);
    // }
    const ixns = [];
    // Check if the user has created a user token account. If not, they'll need to do that first.
    const payerTokenAcct = await getPayerTokenAccount(program.provider.connection, payerPubkey, mint.address);
    if (payerTokenAcct.ixn) {
        ixns.push(payerTokenAcct.ixn);
    }
    // TODO: if fundLeaseAmount, check payer has enough funds
    ixns.push(...[
        // allocate aggregator account
        anchor.web3.SystemProgram.createAccount({
            fromPubkey: (0, switchboard_v2_1.programWallet)(program).publicKey,
            newAccountPubkey: aggregatorKeypair.publicKey,
            space: size,
            lamports: await program.provider.connection.getMinimumBalanceForRentExemption(size),
            programId: program.programId,
        }),
        // create aggregator
        await program.methods
            .aggregatorInit({
            name: ((_c = params.name) !== null && _c !== void 0 ? _c : Buffer.from("")).slice(0, 32),
            metadata: ((_d = params.metadata) !== null && _d !== void 0 ? _d : Buffer.from("")).slice(0, 128),
            batchSize: params.batchSize,
            minOracleResults: params.minRequiredOracleResults,
            minJobResults: params.minRequiredJobResults,
            minUpdateDelaySeconds: params.minUpdateDelaySeconds,
            varianceThreshold: switchboard_v2_1.SwitchboardDecimal.fromBig(new big_js_1.default((_e = params.varianceThreshold) !== null && _e !== void 0 ? _e : 0)),
            forceReportPeriod: (_f = params.forceReportPeriod) !== null && _f !== void 0 ? _f : new anchor.BN(0),
            expiration: (_g = params.expiration) !== null && _g !== void 0 ? _g : new anchor.BN(0),
            stateBump,
        })
            .accounts({
            aggregator: aggregatorKeypair.publicKey,
            authority,
            queue: params.queueAccount.publicKey,
            // authorWallet: params.authorWallet ?? state.tokenVault,
            programState: programStateAccount.publicKey,
        })
            .instruction(),
        await program.methods
            .permissionInit({})
            .accounts({
            permission: permissionAccount.publicKey,
            authority: queue.authority,
            granter: queueAccount.publicKey,
            grantee: aggregatorKeypair.publicKey,
            payer: payerPubkey,
            systemProgram: anchor.web3.SystemProgram.programId,
        })
            .instruction(),
        payerPubkey.equals(queue.authority)
            ? await program.methods
                .permissionSet({
                permission: { permitOracleQueueUsage: null },
                enable: true,
            })
                .accounts({
                permission: permissionAccount.publicKey,
                authority: queue.authority,
            })
                .instruction()
            : undefined,
        spl.createAssociatedTokenAccountInstruction(payerPubkey, leaseEscrow, leaseAccount.publicKey, mint.address),
        await program.methods
            .leaseInit({
            loadAmount: fundLeaseAmount,
            stateBump,
            leaseBump,
            withdrawAuthority: payerPubkey,
            walletBumps: Buffer.from([]),
        })
            .accounts({
            programState: programStateAccount.publicKey,
            lease: leaseAccount.publicKey,
            queue: queueAccount.publicKey,
            aggregator: aggregatorAccount.publicKey,
            systemProgram: anchor.web3.SystemProgram.programId,
            funder: payerTokenAcct.publicKey,
            payer: payerPubkey,
            tokenProgram: spl.TOKEN_PROGRAM_ID,
            escrow: leaseEscrow,
            owner: payerPubkey,
            mint: mint.address,
        })
            // .remainingAccounts(
            //   jobPubkeys.concat(jobWallets).map((pubkey: PublicKey) => {
            //     return { isSigner: false, isWritable: true, pubkey };
            //   })
            // )
            .instruction(),
        ...(await Promise.all(jobs.map(async ([jobAccount, weight]) => {
            return program.methods
                .aggregatorAddJob({
                weight,
            })
                .accounts({
                aggregator: aggregatorKeypair.publicKey,
                authority,
                job: jobAccount.publicKey,
            })
                .instruction();
        }))),
    ].filter(Boolean));
    return {
        ixns: ixns,
        signers: [aggregatorKeypair],
        account: aggregatorAccount,
    };
}
exports.createAggregatorReq = createAggregatorReq;
//# sourceMappingURL=feed.js.map