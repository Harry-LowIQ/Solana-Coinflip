"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getWorkspace = exports.loadPid = exports.getAnchorCluster = exports.getAnchorWalletPath = exports.verifyProgramHasPayer = exports.getProgramPayer = exports.programHasPayer = exports.getIdlAddress = exports.getProgramDataAddress = exports.getDefaultProvider = exports.programWallet = void 0;
const anchor = __importStar(require("@project-serum/anchor"));
/*eslint-disable import/extensions */
const pubkey_js_1 = require("@project-serum/anchor/dist/cjs/utils/pubkey.js");
const web3_js_1 = require("@solana/web3.js");
const switchboard_v2_1 = require("@switchboard-xyz/switchboard-v2");
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const toml_1 = __importDefault(require("toml"));
const const_js_1 = require("./const.js");
const errors_js_1 = require("./errors.js");
function programWallet(program) {
    return program.provider.wallet
        .payer;
}
exports.programWallet = programWallet;
/** Return the default anchor.AnchorProvider that will fail if a transaction is sent. This is used to avoid accidentally loading a
 * valid keypair from the anchor environment defaults.
 * @param connection a Solana connection object for a given Solana cluster and endpoint
 * @return the anchor.AnchorProvider object
 * */
const getDefaultProvider = (connection) => {
    return new anchor.AnchorProvider(connection, new switchboard_v2_1.AnchorWallet(const_js_1.DEFAULT_KEYPAIR), anchor.AnchorProvider.defaultOptions());
};
exports.getDefaultProvider = getDefaultProvider;
/** Get the program data address for a given programId
 * @param programId the programId for a given on-chain program
 * @return the publicKey of the address holding the upgradeable program buffer
 */
const getProgramDataAddress = (programId) => {
    return (0, pubkey_js_1.findProgramAddressSync)([programId.toBytes()], new web3_js_1.PublicKey("BPFLoaderUpgradeab1e11111111111111111111111"))[0];
};
exports.getProgramDataAddress = getProgramDataAddress;
/** Get the IDL address for a given programId
 * @param programId the programId for a given on-chain program
 * @return the publicKey of the IDL address
 */
const getIdlAddress = async (programId) => {
    const base = (await web3_js_1.PublicKey.findProgramAddress([], programId))[0];
    return web3_js_1.PublicKey.createWithSeed(base, "anchor:idl", programId);
};
exports.getIdlAddress = getIdlAddress;
const programHasPayer = (program) => {
    const payer = programWallet(program);
    return !payer.publicKey.equals(const_js_1.DEFAULT_KEYPAIR.publicKey);
};
exports.programHasPayer = programHasPayer;
const getProgramPayer = (program) => {
    const wallet = programWallet(program);
    if ((0, exports.programHasPayer)(program)) {
        return wallet;
    }
    throw new errors_js_1.NoPayerKeypairProvided();
};
exports.getProgramPayer = getProgramPayer;
const verifyProgramHasPayer = (program) => {
    if ((0, exports.programHasPayer)(program)) {
        return;
    }
    throw new errors_js_1.NoPayerKeypairProvided();
};
exports.verifyProgramHasPayer = verifyProgramHasPayer;
function getAnchorWalletPath(parsedToml) {
    let tomlData;
    if (parsedToml) {
        tomlData = parsedToml;
    }
    else {
        const tomlPath = path_1.default.join(process.cwd(), "Anchor.toml");
        if (!fs_1.default.existsSync(tomlPath)) {
            throw new Error(`failed to find Anchor.toml`);
        }
        tomlData = toml_1.default.parse(fs_1.default.readFileSync(tomlPath, "utf8"));
    }
    const walletPath = tomlData.provider.wallet;
    if (!walletPath) {
        throw new Error(`Failed to read wallet path`);
    }
    return walletPath;
}
exports.getAnchorWalletPath = getAnchorWalletPath;
function getAnchorCluster(parsedToml) {
    let tomlData;
    if (parsedToml) {
        tomlData = parsedToml;
    }
    else {
        const tomlPath = path_1.default.join(process.cwd(), "Anchor.toml");
        if (!fs_1.default.existsSync(tomlPath)) {
            throw new Error(`failed to find Anchor.toml`);
        }
        tomlData = toml_1.default.parse(fs_1.default.readFileSync(tomlPath, "utf8"));
    }
    const cluster = tomlData.provider.cluster;
    if (!cluster) {
        throw new Error(`Failed to read Anchor.toml cluster`);
    }
    return cluster;
}
exports.getAnchorCluster = getAnchorCluster;
function loadPid(programKeypairPath) {
    if (!fs_1.default.existsSync(programKeypairPath)) {
        console.log(programKeypairPath);
        throw new Error(`Could not find keypair. Have you run 'anchor build'?`);
    }
    const programKeypair = web3_js_1.Keypair.fromSecretKey(new Uint8Array(JSON.parse(fs_1.default.readFileSync(programKeypairPath, "utf8"))));
    return programKeypair.publicKey;
}
exports.loadPid = loadPid;
function getWorkspace(programName, programPath) {
    const tomlPath = path_1.default.join(programPath, "Anchor.toml");
    if (!fs_1.default.existsSync(tomlPath)) {
        throw new Error(`failed to find Anchor.toml`);
    }
    const tomlData = toml_1.default.parse(fs_1.default.readFileSync(tomlPath, "utf8"));
    const cluster = tomlData.provider.cluster;
    const wallet = web3_js_1.Keypair.fromSecretKey(Buffer.from(JSON.parse(fs_1.default.readFileSync(tomlData.provider.wallet, {
        encoding: "utf-8",
    }))));
    const programKeypairPath = path_1.default.join(programPath, `target/deploy/${programName.replace("-", "_")}-keypair.json`);
    let programId;
    switch (cluster) {
        case "localnet":
            programId = new web3_js_1.PublicKey(tomlData.programs.localnet[programName]);
            break;
        case "devnet":
            programId = new web3_js_1.PublicKey(tomlData.programs.devnet[programName]);
            break;
        case "mainnet-beta":
            programId = new web3_js_1.PublicKey(tomlData.programs.mainnet[programName]);
            break;
        default:
            programId = loadPid(programKeypairPath);
    }
    const programIdlPath = path_1.default.join(programPath, `target/idl/${programName.replace("-", "_")}.json`);
    const idl = JSON.parse(fs_1.default.readFileSync(programIdlPath, "utf-8"));
    const url = cluster === "localnet" ? "http://localhost:8899" : (0, web3_js_1.clusterApiUrl)(cluster);
    const provider = new anchor.AnchorProvider(new web3_js_1.Connection(url, { commitment: "confirmed" }), new switchboard_v2_1.AnchorWallet(wallet), { commitment: "confirmed" });
    return new anchor.Program(idl, programId, provider);
}
exports.getWorkspace = getWorkspace;
//# sourceMappingURL=anchor.js.map