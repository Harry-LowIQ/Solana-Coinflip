"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BigUtils = void 0;
const anchor = __importStar(require("@project-serum/anchor"));
const switchboard_v2_1 = require("@switchboard-xyz/switchboard-v2");
const big_js_1 = __importDefault(require("big.js"));
const decimal_js_1 = __importDefault(require("decimal.js"));
class BigUtils {
    static safeDiv(number_, denominator, decimals = 20) {
        const oldDp = big_js_1.default.DP;
        big_js_1.default.DP = decimals;
        const result = number_.div(denominator);
        big_js_1.default.DP = oldDp;
        return result;
    }
    static safeMul(...n) {
        if (n.length === 0) {
            throw new Error(`need to provide elements to multiply ${n}`);
        }
        let result = new big_js_1.default(1);
        for (const x of n) {
            result = result.mul(x);
        }
        return result;
    }
    static safeNthRoot(big, nthRoot, decimals = 20) {
        if (nthRoot <= 0) {
            throw new Error(`cannot take the nth root of a negative number`);
        }
        const oldDp = big_js_1.default.DP;
        big_js_1.default.DP = decimals;
        const decimal = BigUtils.toDecimal(big);
        const frac = new decimal_js_1.default(1).div(nthRoot);
        const root = big.s === -1
            ? decimal.abs().pow(frac).mul(new decimal_js_1.default(big.s))
            : decimal.pow(frac);
        const result = BigUtils.fromDecimal(root);
        big_js_1.default.DP = oldDp;
        return result;
    }
    static safeSqrt(n, decimals = 20) {
        const oldDp = big_js_1.default.DP;
        big_js_1.default.DP = decimals;
        const result = n.sqrt();
        big_js_1.default.DP = oldDp;
        return result;
    }
    static safePow(n, exp, decimals = 20) {
        const oldDp = big_js_1.default.DP;
        big_js_1.default.DP = decimals;
        const oldPrecision = decimal_js_1.default.precision;
        decimal_js_1.default.set({ precision: decimals });
        const base = BigUtils.toDecimal(n);
        const value = base.pow(exp);
        const result = BigUtils.fromDecimal(value);
        decimal_js_1.default.set({ precision: oldPrecision });
        big_js_1.default.DP = oldDp;
        return result;
    }
    static fromBN(n, decimals = 0) {
        const big = new switchboard_v2_1.SwitchboardDecimal(n, decimals).toBig();
        // assert(n.cmp(new anchor.BN(big.toFixed())) === 0);
        return big;
    }
    static toDecimal(big, decimals = 20) {
        const decimal = new decimal_js_1.default(big.toFixed(decimals, 0));
        // assert(decimal.toFixed() === big.toFixed());
        return decimal;
        // const b = new Big(big);
        // const decimal = new Decimal(0);
        // (decimal as any).d = groupArray(b.c);
        // (decimal as any).e = b.e;
        // (decimal as any).s = b.s;
        // console.log(`toDecimal: ${big.toString()} => ${decimal.toString()}`);
        // return decimal;
    }
    static fromDecimal(decimal, decimals = 20) {
        if (decimal.isNaN()) {
            throw new TypeError(`cannot convert NaN decimal.js to Big.js`);
        }
        if (!decimal.isFinite()) {
            throw new TypeError(`cannot convert INF decimal.js to Big.js`);
        }
        const big = new big_js_1.default(decimal.toFixed(decimals, 0));
        // assert(big.toFixed() === decimal.toFixed());
        return big;
        // const d = new Decimal(decimal);
        // const big = new Big(0);
        // console.log(`fromDecimal (${d.toString()}) d.d ${d.d}`);
        // big.c = splitToDigits(d.d);
        // big.e = d.e;
        // big.s = d.s;
        // console.log(`fromDecimal: ${decimal.toString()} => ${big.toString()}`);
        // return big;
    }
    static fromOrcaU64(u64) {
        return BigUtils.fromBN(new anchor.BN(u64.value), u64.scale);
    }
    static fromSaberTokenAmount(token) {
        return BigUtils.fromBN(new anchor.BN(token.toU64()), token.token.info.decimals);
    }
    static fromTokenAmount(token) {
        return BigUtils.fromBN(new anchor.BN(token.amount), token.decimals);
    }
    static fromPrice(price) {
        const numerator = new big_js_1.default(price.numerator.toString());
        const denominator = new big_js_1.default(price.denominator.toString());
        return BigUtils.safeDiv(numerator, denominator);
    }
}
exports.BigUtils = BigUtils;
//# sourceMappingURL=big.js.map