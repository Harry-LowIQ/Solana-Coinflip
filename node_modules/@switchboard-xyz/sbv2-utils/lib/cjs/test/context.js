"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SwitchboardTestContext = void 0;
/* eslint-disable @typescript-eslint/no-shadow */
/* eslint-disable @typescript-eslint/no-var-requires */
const anchor = __importStar(require("@project-serum/anchor"));
const spl = __importStar(require("@solana/spl-token-v2"));
const web3_js_1 = require("@solana/web3.js");
const sbv2 = __importStar(require("@switchboard-xyz/switchboard-v2"));
const big_js_1 = __importDefault(require("big.js"));
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const async_js_1 = require("../async.js");
const feed_js_1 = require("../feed.js");
const token_js_1 = require("../token.js");
class SwitchboardTestContext {
    constructor(ctx) {
        this.program = ctx.program;
        this.mint = ctx.mint;
        this.payerTokenWallet = ctx.payerTokenWallet;
        this.queue = ctx.queue;
        this.oracle = ctx.oracle;
    }
    /** Load the associated token wallet for the given payer with a prefunded balance
     * @param program anchor program
     * @param mint the switchboard mint address
     * @param tokenAmount number of tokens to populate in switchboard mint's associated token account
     */
    static async getOrCreateSwitchboardWallet(program, mint, tokenAmount) {
        const payerKeypair = sbv2.programWallet(program);
        if (tokenAmount <= 0) {
            return spl.getAssociatedTokenAddress(mint.address, payerKeypair.publicKey);
        }
        const associatedTokenAccount = await spl.getOrCreateAssociatedTokenAccount(program.provider.connection, payerKeypair, mint.address, payerKeypair.publicKey);
        if (tokenAmount <= associatedTokenAccount.amount) {
            return associatedTokenAccount.address;
        }
        const amountNeeded = tokenAmount - Number(associatedTokenAccount.amount);
        if (amountNeeded <= 0) {
            return associatedTokenAccount.address;
        }
        const balance = await program.provider.connection.getBalance(payerKeypair.publicKey);
        if (amountNeeded > balance) {
            throw new Error(`Payer account does not enough balance to fund new token account, need ${amountNeeded}, have ${balance}`);
        }
        const finalBalance = await (0, token_js_1.transferWrappedSol)(program.provider.connection, payerKeypair, amountNeeded);
        return associatedTokenAccount.address;
    }
    /** Load SwitchboardTestContext using a specified queue
     * @param provider anchor Provider containing connection and payer Keypair
     * @param queueKey the oracle queue to load
     * @param tokenAmount number of tokens to populate in switchboard mint's associated token account
     */
    static async loadDevnetQueue(provider, queueKey = "F8ce7MsckeZAbAGmxjJNetxYXQa9mKr9nnrC3qKubyYy", tokenAmount = 0) {
        const payerKeypair = provider.wallet.payer;
        const balance = await provider.connection.getBalance(payerKeypair.publicKey);
        if (!balance) {
            try {
                await provider.connection.requestAirdrop(payerKeypair.publicKey, 1000000000);
            }
            catch { }
        }
        let program;
        try {
            program = await sbv2.loadSwitchboardProgram("devnet", provider.connection, payerKeypair);
        }
        catch (error) {
            throw new Error(`Failed to load the SBV2 program for the given cluster, ${error.message}`);
        }
        let queue;
        let queueData;
        try {
            queue = new sbv2.OracleQueueAccount({
                program,
                publicKey: new web3_js_1.PublicKey(queueKey),
            });
            queueData = await queue.loadData();
            if (queueData.queue.length < 1) {
                throw new Error(`OracleQueue has no active oracles heartbeating`);
            }
        }
        catch (error) {
            throw new Error(`Failed to load the SBV2 queue for the given cluster, ${error.message}`);
        }
        let mint;
        try {
            mint = await queue.loadMint();
        }
        catch (error) {
            throw new Error(`Failed to load the SBV2 mint for the given cluster, ${error.message}`);
        }
        const payerTokenWallet = await SwitchboardTestContext.getOrCreateSwitchboardWallet(program, mint, tokenAmount);
        return new SwitchboardTestContext({
            program,
            queue,
            mint,
            payerTokenWallet,
        });
    }
    /** Recursively loop through directories and return the filepath of switchboard.env
     * @param envFileName alternative filename to search for. defaults to switchboard.env
     * @returns the filepath for a switchboard env file to load
     */
    static findSwitchboardEnv(envFileName = "switchboard.env") {
        const NotFoundError = new Error("failed to find switchboard.env file in current directory recursively");
        let retryCount = 5;
        let currentDirectory = process.cwd();
        while (retryCount > 0) {
            // look for switchboard.env
            try {
                const currentPath = path_1.default.join(currentDirectory, envFileName);
                if (fs_1.default.existsSync(currentPath)) {
                    return currentPath;
                }
            }
            catch { }
            // look for .switchboard directory
            try {
                const localSbvPath = path_1.default.join(currentDirectory, ".switchboard");
                if (fs_1.default.existsSync(localSbvPath)) {
                    const localSbvEnvPath = path_1.default.join(localSbvPath, envFileName);
                    if (fs_1.default.existsSync(localSbvEnvPath)) {
                        return localSbvEnvPath;
                    }
                }
            }
            catch { }
            currentDirectory = path_1.default.join(currentDirectory, "../");
            --retryCount;
        }
        throw NotFoundError;
    }
    /** Load SwitchboardTestContext from an env file containing $SWITCHBOARD_PROGRAM_ID, $ORACLE_QUEUE, $AGGREGATOR
     * @param provider anchor Provider containing connection and payer Keypair
     * @param filePath filesystem path to env file
     * @param tokenAmount number of tokens to populate in switchboard mint's associated token account
     */
    static async loadFromEnv(provider, filePath = SwitchboardTestContext.findSwitchboardEnv(), tokenAmount = 0) {
        require("dotenv").config({ path: filePath });
        if (!process.env.SWITCHBOARD_PROGRAM_ID) {
            throw new Error(`your env file must have $SWITCHBOARD_PROGRAM_ID set`);
        }
        const payerKeypair = provider.wallet.payer;
        const balance = await provider.connection.getBalance(payerKeypair.publicKey);
        if (!balance) {
            try {
                const airdropSignature = await provider.connection.requestAirdrop(payerKeypair.publicKey, 1000000000);
                await provider.connection.confirmTransaction(airdropSignature);
            }
            catch { }
        }
        const SWITCHBOARD_PID = new web3_js_1.PublicKey(process.env.SWITCHBOARD_PROGRAM_ID);
        const switchboardIdl = await anchor.Program.fetchIdl(SWITCHBOARD_PID, provider);
        if (!switchboardIdl) {
            throw new Error(`failed to load Switchboard IDL`);
        }
        const switchboardProgram = new anchor.Program(switchboardIdl, SWITCHBOARD_PID, provider);
        if (!process.env.ORACLE_QUEUE) {
            throw new Error(`your env file must have $ORACLE_QUEUE set`);
        }
        const SWITCHBOARD_QUEUE = new web3_js_1.PublicKey(process.env.ORACLE_QUEUE);
        const queue = new sbv2.OracleQueueAccount({
            program: switchboardProgram,
            publicKey: SWITCHBOARD_QUEUE,
        });
        const oracle = process.env.ORACLE
            ? new sbv2.OracleAccount({
                program: switchboardProgram,
                publicKey: new web3_js_1.PublicKey(process.env.ORACLE),
            })
            : undefined;
        let mint;
        try {
            mint = await queue.loadMint();
        }
        catch (error) {
            throw new Error(`Failed to load the SBV2 mint for the given cluster, ${error.message}`);
        }
        const payerTokenWallet = await SwitchboardTestContext.getOrCreateSwitchboardWallet(switchboardProgram, mint, tokenAmount);
        const context = {
            program: switchboardProgram,
            mint: mint,
            payerTokenWallet,
            queue,
            oracle,
        };
        return new SwitchboardTestContext(context);
    }
    /** Create a static data feed that resolves to an expected value */
    async createStaticFeed(value, timeout = 30) {
        const payerKeypair = sbv2.programWallet(this.program);
        const staticJob = await sbv2.JobAccount.create(this.program, {
            name: Buffer.from(`Value ${value}`),
            authority: this.payerTokenWallet,
            data: Buffer.from(sbv2.OracleJob.encodeDelimited(sbv2.OracleJob.create({
                tasks: [
                    sbv2.OracleJob.Task.create({
                        valueTask: sbv2.OracleJob.ValueTask.create({
                            value,
                        }),
                    }),
                ],
            })).finish()),
        });
        const aggregatorAccount = await (0, feed_js_1.createAggregator)(this.program, this.queue, {
            batchSize: 1,
            minRequiredJobResults: 1,
            minRequiredOracleResults: 1,
            minUpdateDelaySeconds: 5,
            queueAccount: this.queue,
            authorWallet: this.payerTokenWallet,
            authority: payerKeypair.publicKey,
        }, [[staticJob, 1]]);
        const aggValue = await (0, feed_js_1.awaitOpenRound)(aggregatorAccount, this.queue, this.payerTokenWallet, new big_js_1.default(value), timeout);
        return aggregatorAccount;
    }
    /** Update a feed to a single job that resolves to a new expected value
     * @param aggregatorAccount the aggregator to change a job definition for
     * @param value the new expected value
     * @param timeout how long to wait for the oracle to update the aggregator's latestRound result
     */
    async updateStaticFeed(aggregatorAccount, value, timeout = 30) {
        const payerKeypair = sbv2.programWallet(this.program);
        const aggregator = await aggregatorAccount.loadData();
        const expectedValue = new big_js_1.default(value);
        const queue = await this.queue.loadData();
        // remove all existing jobs
        const existingJobs = aggregator.jobPubkeysData
            // eslint-disable-next-line array-callback-return
            .filter((jobKey) => {
            if (!jobKey.equals(web3_js_1.PublicKey.default)) {
                return jobKey;
            }
            return undefined;
        })
            .filter((item) => item !== undefined)
            .map((jobKey) => new sbv2.JobAccount({
            program: this.program,
            publicKey: jobKey,
        }));
        await Promise.all(existingJobs.map((job) => aggregatorAccount.removeJob(job, payerKeypair)));
        // add new static job
        const staticJob = await sbv2.JobAccount.create(this.program, {
            name: Buffer.from(`Value ${value}`),
            authority: web3_js_1.Keypair.generate().publicKey,
            data: Buffer.from(sbv2.OracleJob.encodeDelimited(sbv2.OracleJob.create({
                tasks: [
                    sbv2.OracleJob.Task.create({
                        valueTask: sbv2.OracleJob.ValueTask.create({
                            value,
                        }),
                    }),
                ],
            })).finish()),
        });
        await aggregatorAccount.addJob(staticJob, payerKeypair);
        const aggValue = await (0, feed_js_1.awaitOpenRound)(aggregatorAccount, this.queue, this.payerTokenWallet, expectedValue, timeout);
    }
    /** Checks whether the queue has any active oracles heartbeating */
    async isQueueReady() {
        const queueData = await this.queue.loadData();
        return queueData.queue.length > 0;
    }
    /** Awaits the specified timeout for an oracle to start heartbeating on the queue
     * @param timeout number of seconds to wait for an oracle to start heartbeating
     */
    async oracleHeartbeat(timeout = 30) {
        const delay = Math.ceil(timeout / 10) * 1000;
        let retryCount = 10;
        while (retryCount) {
            try {
                if (await this.isQueueReady()) {
                    return;
                }
            }
            catch (error) {
                if (!(error instanceof Error) ||
                    !error.toString().includes("connection refused")) {
                    throw error;
                }
            }
            await (0, async_js_1.sleep)(delay);
            --retryCount;
        }
        if (timeout <= 0) {
            throw new Error(`Timed out waiting for the OracleQueue to have an active oracle heartbeating`);
        }
    }
}
exports.SwitchboardTestContext = SwitchboardTestContext;
//# sourceMappingURL=context.js.map