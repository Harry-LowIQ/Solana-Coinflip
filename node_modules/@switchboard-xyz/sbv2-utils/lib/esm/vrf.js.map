{"version":3,"file":"vrf.js","sourceRoot":"","sources":["../../src/vrf.ts"],"names":[],"mappings":"AAAA,OAAO,KAAK,MAAM,MAAM,uBAAuB,CAAC;AAChD,OAAO,EAAE,SAAS,EAAE,MAAM,iBAAiB,CAAC;AAE5C,OAAO,EAAE,kBAAkB,EAAE,MAAM,YAAY,CAAC;AAEhD,MAAM,CAAC,KAAK,UAAU,cAAc,CAClC,UAAsB,EACtB,OAAkB,EAClB,OAAO,GAAG,EAAE;IAEZ,yCAAyC;IACzC,MAAM,aAAa,GAAG,IAAI,MAAM,CAAC,kBAAkB,CAAC,UAAU,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC;IAE5E,IAAI,SAAiB,CAAC;IACtB,MAAM,kBAAkB,GAAG,IAAI,OAAO,CAAC,CAAC,OAAgC,EAAE,EAAE;;QAC1E,SAAS,GAAG,UAAU,CAAC,OAAO,CAAC,QAAQ,CAAC,UAAU,CAAC,eAAe,CAChE,MAAA,UAAU,aAAV,UAAU,uBAAV,UAAU,CAAE,SAAS,mCAAI,SAAS,CAAC,OAAO,EAC1C,KAAK,EAAE,WAAW,EAAE,EAAE;YACpB,MAAM,GAAG,GAAG,aAAa,CAAC,MAAM,CAAC,gBAAgB,EAAE,WAAW,CAAC,IAAI,CAAC,CAAC;YACrE,IAAI,CAAC,OAAO,CAAC,EAAE,CAAC,GAAG,CAAC,OAAO,CAAC,EAAE;gBAC5B,OAAO;aACR;YACD,IAAI,GAAG,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC,GAAG,EAAE,EAAE,CAAC,GAAG,KAAK,CAAC,CAAC,EAAE;gBACxC,OAAO;aACR;YACD,OAAO,CAAC,GAAG,CAAC,MAAgB,CAAC,CAAC;QAChC,CAAC,CACF,CAAC;IACJ,CAAC,CAAC,CAAC;IAEH,MAAM,mBAAmB,GAAG,kBAAkB,CAC5C,OAAO,GAAG,IAAI,EACd,kBAAkB,EAClB,IAAI,KAAK,CAAC,2BAA2B,OAAO,UAAU,CAAC,CACxD,CAAC,OAAO,CAAC,GAAG,EAAE;QACb,IAAI,SAAS,EAAE;YACb,UAAU,CAAC,OAAO,CAAC,QAAQ,CAAC,UAAU,CAAC,2BAA2B,CAChE,SAAS,CACV,CAAC;SACH;IACH,CAAC,CAAC,CAAC;IAEH,MAAM,MAAM,GAAG,MAAM,mBAAmB,CAAC;IAEzC,IAAI,CAAC,MAAM,EAAE;QACX,MAAM,IAAI,KAAK,CAAC,sBAAsB,CAAC,CAAC;KACzC;IAED,OAAO,MAAM,CAAC;AAChB,CAAC","sourcesContent":["import * as anchor from \"@project-serum/anchor\";\nimport { PublicKey } from \"@solana/web3.js\";\nimport { VrfAccount } from \"@switchboard-xyz/switchboard-v2\";\nimport { promiseWithTimeout } from \"./async.js\";\n\nexport async function awaitOpenRound(\n  vrfAccount: VrfAccount,\n  counter: anchor.BN,\n  timeout = 30\n): Promise<Buffer> {\n  // call open round and wait for new value\n  const accountsCoder = new anchor.BorshAccountsCoder(vrfAccount.program.idl);\n\n  let accountWs: number;\n  const awaitUpdatePromise = new Promise((resolve: (value: Buffer) => void) => {\n    accountWs = vrfAccount.program.provider.connection.onAccountChange(\n      vrfAccount?.publicKey ?? PublicKey.default,\n      async (accountInfo) => {\n        const vrf = accountsCoder.decode(\"VrfAccountData\", accountInfo.data);\n        if (!counter.eq(vrf.counter)) {\n          return;\n        }\n        if (vrf.result.every((val) => val === 0)) {\n          return;\n        }\n        resolve(vrf.result as Buffer);\n      }\n    );\n  });\n\n  const updatedValuePromise = promiseWithTimeout(\n    timeout * 1000,\n    awaitUpdatePromise,\n    new Error(`vrf failed to update in ${timeout} seconds`)\n  ).finally(() => {\n    if (accountWs) {\n      vrfAccount.program.provider.connection.removeAccountChangeListener(\n        accountWs\n      );\n    }\n  });\n\n  const result = await updatedValuePromise;\n\n  if (!result) {\n    throw new Error(`failed to update VRF`);\n  }\n\n  return result;\n}\n"]}